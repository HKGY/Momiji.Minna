<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <title>CelestialDX - 图形节奏音乐游戏</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding: 16px;
            overflow: hidden;
            background: radial-gradient(circle at top, #020617, #020617 60%, #000 100%);
            color: #f5f5f5;
        }

        h1 {
            margin-bottom: 10px;
            text-align: center;
        }

        .logo-main {
            display: block;
            font-size: 32px;
            letter-spacing: 0.35em;
            text-transform: uppercase;
            background: linear-gradient(120deg, #fb923c, #ec4899, #4f46e5, #22d3ee);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow:
                0 0 18px rgba(59, 130, 246, 0.9),
                0 0 36px rgba(236, 72, 153, 0.8);
        }

        .logo-sub {
            display: block;
            margin-top: 4px;
            font-size: 11px;
            letter-spacing: 0.22em;
            text-transform: uppercase;
            color: rgba(226, 232, 240, 0.7);
        }

        .panel {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 6px 12px;
            border-radius: 999px;
            background: radial-gradient(circle at top, rgba(15, 23, 42, 0.9), rgba(15, 23, 42, 0.4));
            box-shadow: 0 12px 40px rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(10px);
        }

        .panel label {
            font-size: 13px;
            opacity: 0.9;
        }

        input[type="file"] {
            font-size: 13px;
            max-width: 240px;
        }

        select {
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.7);
            background: rgba(15, 23, 42, 0.9);
            color: #e5e7eb;
            padding: 4px 10px;
            font-size: 13px;
            outline: none;
        }

        button {
            border: none;
            padding: 8px 14px;
            border-radius: 999px;
            font-size: 13px;
            cursor: pointer;
            background: linear-gradient(135deg, #4f46e5, #ec4899);
            color: white;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
            transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease, background 0.2s ease;
            outline: none;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.35), transparent 60%);
            opacity: 0;
            transition: opacity 0.25s ease;
        }

        button:disabled {
            opacity: 0.45;
            cursor: default;
            box-shadow: none;
            filter: grayscale(0.3);
        }

        button:not(:disabled):hover {
            transform: translateY(-1px) scale(1.04);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.7);
            filter: brightness(1.07);
        }

        button:not(:disabled):hover::before {
            opacity: 1;
        }

        .info {
            font-size: 13px;
            opacity: 0.78;
            margin-bottom: 4px;
            text-align: center;
        }

        #songTitle {
            font-size: 13px;
            opacity: 0.88;
            margin-bottom: 6px;
            text-align: center;
        }

        .stats {
            display: flex;
            gap: 14px;
            font-size: 13px;
            margin-bottom: 4px;
            align-items: baseline;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stats span.label {
            opacity: 0.7;
            margin-right: 4px;
        }

        .stats .value {
            font-weight: 600;
        }

        .judge-stats {
            display: flex;
            gap: 12px;
            font-size: 12px;
            margin-bottom: 6px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .judge-stats span {
            opacity: 0.85;
        }

        .judge-stats .perfect {
            color: #fef9c3;
        }

        .judge-stats .good {
            color: #bbf7d0;
        }

        .judge-stats .bad {
            color: #fed7aa;
        }

        .judge-stats .miss {
            color: #fecaca;
        }

        .hint {
            margin-top: 2px;
            font-size: 12px;
            opacity: 0.6;
            text-align: center;
            margin-bottom: 4px;
        }

        #offsetStats {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 8px;
            text-align: center;
        }

        .game-wrapper {
            position: relative;
            display: inline-block;
        }

        canvas {
            border-radius: 26px;
            box-shadow:
                0 20px 70px rgba(0, 0, 0, 0.8),
                0 0 60px rgba(56, 189, 248, 0.2);
            background: #020617;
            max-width: 100%;
            display: block;
        }

        .center-hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            text-shadow: 0 0 16px rgba(0, 0, 0, 0.9);
        }

        .center-score {
            font-size: 26px;
            margin-bottom: 4px;
            letter-spacing: 2px;
            z-index: 1;
            color: #e5e7eb;
            text-shadow:
                0 0 22px rgba(59, 130, 246, 0.9),
                0 0 40px rgba(236, 72, 153, 0.85);
        }

        .center-combo {
            font-size: 16px;
            margin-bottom: 6px;
            opacity: 0.98;
            z-index: 1;
            color: #f9fafb;
            text-shadow:
                0 0 16px rgba(56, 189, 248, 0.9),
                0 0 26px rgba(37, 99, 235, 0.9);
        }

        .center-judge {
            min-height: 30px;
            font-size: 26px;
            font-weight: 800;
            letter-spacing: 6px;
            text-transform: uppercase;
            z-index: 2;
            transition: transform 0.1s ease;
        }

        .progress-bar-container {
            position: absolute;
            left: 50%;
            top: 10px;
            transform: translateX(-50%);
            width: min(70vw, 640px);
            height: 6px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.9);
            overflow: hidden;
            box-shadow:
                0 0 0 1px rgba(148, 163, 184, 0.6),
                0 6px 20px rgba(0, 0, 0, 0.8);
            z-index: 5;
        }

        .progress-bar-fill {
            width: 100%;
            height: 100%;
            transform-origin: left center;
            transform: scaleX(0);
            background: linear-gradient(90deg, #22d3ee, #a855f7, #fb923c);
        }

        .fullscreen-play {
            position: fixed !important;
            inset: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999;
            background: #000;
            margin: 0 !important;
            padding: 0 !important;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fullscreen-play canvas {
            width: 100vw !important;
            height: 100vh !important;
            object-fit: contain;
        }

        .pause-overlay {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(14px);
            z-index: 20;
        }

        .pause-panel {
            background: rgba(15, 23, 42, 0.98);
            border-radius: 24px;
            padding: 20px 28px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
            text-align: center;
            min-width: 260px;
        }

        .pause-title {
            font-size: 18px;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .pause-sub {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 16px;
        }

        .pause-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .pause-buttons button {
            min-width: 90px;
        }

        .start-button {
            position: absolute;
            left: 50%;
            top: 60%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 14px 34px;
            border-radius: 999px;
            font-size: 16px;
            letter-spacing: 0.26em;
            text-transform: uppercase;
            background:
                radial-gradient(circle at top, #38bdf8, #4f46e5 35%, #6d28d9 70%, #f97316 100%);
            box-shadow:
                0 0 0 1px rgba(248, 250, 252, 0.6),
                0 18px 45px rgba(15, 23, 42, 0.95),
                0 0 45px rgba(129, 140, 248, 0.9);
            color: #f9fafb;
            cursor: pointer;
            border: none;
            z-index: 10;
        }

        .start-button .start-main {
            font-weight: 700;
            font-size: 18px;
        }

        .start-button .start-sub {
            margin-top: 4px;
            font-size: 11px;
            letter-spacing: 0.16em;
            opacity: 0.85;
        }

        .start-button:disabled {
            opacity: 0.4;
            cursor: default;
            box-shadow: none;
        }

        .start-button:not(:disabled):hover {
            transform: translate(-50%, -50%) scale(1.04);
            box-shadow:
                0 0 0 1px rgba(248, 250, 252, 0.9),
                0 22px 55px rgba(15, 23, 42, 1),
                0 0 70px rgba(129, 140, 248, 1);
            filter: brightness(1.06);
        }

        .result-overlay {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(15, 23, 42, 0.92);
            backdrop-filter: blur(18px);
            z-index: 30;
        }

        .result-panel {
            background: radial-gradient(circle at top, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 1));
            border-radius: 26px;
            padding: 24px 30px;
            box-shadow: 0 28px 80px rgba(0, 0, 0, 0.95);
            min-width: min(480px, 90vw);
            color: #e5e7eb;
        }

        .result-title {
            font-size: 13px;
            letter-spacing: 0.28em;
            text-transform: uppercase;
            opacity: 0.75;
            margin-bottom: 8px;
        }

        .result-song {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .result-main-line {
            display: flex;
            align-items: baseline;
            gap: 16px;
            margin-bottom: 4px;
        }

        .result-grade {
            font-size: 52px;
            font-weight: 800;
            letter-spacing: 0.16em;
        }

        .result-score {
            font-size: 26px;
            font-weight: 600;
        }

        .result-clear {
            font-size: 18px;
            margin-top: 4px;
        }

        .result-subtitle-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .result-stats {
            font-size: 13px;
            line-height: 1.6;
            margin-bottom: 14px;
        }

        .result-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        .result-buttons button {
            min-width: 90px;
        }

        .footer {
            margin-top: 8px;
            font-size: 11px;
            opacity: 0.4;
            text-align: center;
        }
    </style>
</head>

<body>
    <h1>
        <span class="logo-main">CelestialDX</span>
        <span class="logo-sub">Graphical Rhythm Engine</span>
    </h1>

    <div class="panel">
        <label>
            选择 MP3：
            <input type="file" id="fileInput" accept="audio/mpeg,audio/mp3" />
        </label>
        <label>
            难度：
            <select id="difficultySelect">
                <option value="classic">Classic (≈45 NPM)</option>
                <option value="expert">Expert (≈75 NPM)</option>
                <option value="master">Master (≈110 NPM)</option>
                <option value="legendary">Legendary (≈150 NPM)</option>
            </select>
        </label>
        <button id="useExampleBtn">示例歌曲预览</button>
        <button id="exportScoreBtn" disabled>导出成绩图</button>
    </div>

    <div id="songTitle">当前乐曲：-</div>

    <div class="info" id="infoText">
        请选择一首 mp3，程序会用频域分析 + pattern 自动生成节奏谱面。<br />
        游戏中：图形对齐判定圈时按下 <b>任意键（除 Esc）</b> 或点击 / 触摸；按 <b>Esc</b> 打开暂停菜单。
    </div>

    <div class="stats">
        <div>
            <span class="label">Score</span>
            <span class="value" id="scorePercent">0.0000%</span>
        </div>
        <div>
            <span class="label">Grade</span>
            <span class="value" id="scoreGrade">D</span>
        </div>
        <div>
            <span class="label">Combo</span>
            <span class="value" id="combo">0</span>
        </div>
        <div>
            <span class="label">Max Combo</span>
            <span class="value" id="maxCombo">0</span>
        </div>
        <div>
            <span class="label">Notes</span>
            <span class="value" id="noteCount">0</span>
        </div>
        <div>
            <span class="label">NPM</span>
            <span class="value" id="npm">0.0</span>
        </div>
    </div>

    <div class="judge-stats">
        <span class="perfect">PERFECT: <span id="countPerfect">0</span></span>
        <span class="good">GOOD: <span id="countGood">0</span></span>
        <span class="bad">BAD: <span id="countBad">0</span></span>
        <span class="miss">MISS: <span id="countMiss">0</span></span>
    </div>

    <div class="hint">
        分数以 100.0000% 为基准：PERFECT = 1.0，GOOD = 0.7，BAD = 0.4，MISS = 0。金色音符权重 ×3。<br />
        额外根据最大连击加最多 +2% 加成，可突破 100% 拿到 SSS+。
    </div>

    <div class="info" id="offsetStats"></div>

    <div id="gameContainer" class="game-wrapper">
        <div class="progress-bar-container">
            <div id="progressBarFill" class="progress-bar-fill"></div>
        </div>
        <canvas id="gameCanvas" width="900" height="540"></canvas>
        <div class="center-hud">
            <div id="centerScore" class="center-score">0.0000% [D]</div>
            <div id="centerCombo" class="center-combo">Combo 0</div>
            <div id="judgementText" class="center-judge"></div>
        </div>

        <button id="startBtn" class="start-button" disabled>
            <span class="start-main">START</span>
            <span class="start-sub">点击或按任意键开始</span>
        </button>

        <div id="pauseOverlay" class="pause-overlay">
            <div class="pause-panel">
                <div class="pause-title">PAUSED</div>
                <div class="pause-sub" id="pauseSongTitle">当前乐曲：-</div>
                <div class="pause-buttons">
                    <button id="resumeBtn">继续</button>
                    <button id="retryBtn">重试</button>
                    <button id="quitBtn">退出</button>
                </div>
            </div>
        </div>

        <div id="resultOverlay" class="result-overlay">
            <div class="result-panel">
                <div class="result-title">RESULT</div>
                <div class="result-song" id="resultSongTitle">乐曲：-</div>

                <div class="result-main-line">
                    <div id="resultGrade" class="result-grade">D</div>
                    <div id="resultScore" class="result-score">0.0000%</div>
                </div>
                <div id="resultClear" class="result-clear"></div>

                <div class="result-subtitle-row">
                    <div id="resultDifficulty">难度：-</div>
                    <div id="resultNpm">密度：0.0 NPM</div>
                </div>

                <div id="resultStats" class="result-stats">
                    Max Combo: 0<br />
                    PERFECT: 0 · GOOD: 0 · BAD: 0 · MISS: 0 · Notes: 0
                </div>

                <div class="result-buttons">
                    <button id="resultExportBtn">导出成绩图</button>
                    <button id="resultRetryBtn">重试</button>
                    <button id="resultExitBtn">返回</button>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">点击 / 触摸屏幕任意位置也能打击音符</div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        const fileInput = document.getElementById("fileInput");
        const difficultySelect = document.getElementById("difficultySelect");
        const startBtn = document.getElementById("startBtn");
        const infoText = document.getElementById("infoText");
        const useExampleBtn = document.getElementById("useExampleBtn");
        const exportScoreBtn = document.getElementById("exportScoreBtn");
        const offsetStatsEl = document.getElementById("offsetStats");
        const songTitleEl = document.getElementById("songTitle");
        const pauseOverlay = document.getElementById("pauseOverlay");
        const pauseSongTitle = document.getElementById("pauseSongTitle");
        const resumeBtn = document.getElementById("resumeBtn");
        const retryBtn = document.getElementById("retryBtn");
        const quitBtn = document.getElementById("quitBtn");
        const progressBarFill = document.getElementById("progressBarFill");

        const resultOverlay = document.getElementById("resultOverlay");
        const resultSongTitle = document.getElementById("resultSongTitle");
        const resultGradeEl = document.getElementById("resultGrade");
        const resultScoreEl = document.getElementById("resultScore");
        const resultClearEl = document.getElementById("resultClear");
        const resultDifficultyEl = document.getElementById("resultDifficulty");
        const resultNpmEl = document.getElementById("resultNpm");
        const resultStatsEl = document.getElementById("resultStats");
        const resultRetryBtn = document.getElementById("resultRetryBtn");
        const resultExitBtn = document.getElementById("resultExitBtn");
        const resultExportBtn = document.getElementById("resultExportBtn");

        const scorePercentEl = document.getElementById("scorePercent");
        const scoreGradeEl = document.getElementById("scoreGrade");
        const comboEl = document.getElementById("combo");
        const maxComboEl = document.getElementById("maxCombo");
        const noteCountEl = document.getElementById("noteCount");
        const npmEl = document.getElementById("npm");

        const countPerfectEl = document.getElementById("countPerfect");
        const countGoodEl = document.getElementById("countGood");
        const countBadEl = document.getElementById("countBad");
        const countMissEl = document.getElementById("countMiss");

        const centreScoreEl = document.getElementById("centerScore");
        const centreComboEl = document.getElementById("centerCombo");
        const judgementTextEl = document.getElementById("judgementText");

        const OUTLINE_SHOW_BEFORE = 0.5;
        const OUTLINE_HIDE_AFTER = 0.25;
        const EXAMPLE_MP3_URL = "example.mp3";
        const JUDGE_WINDOW_SCALE = 2;
        const SAFE_LEAD_IN = 1.5;

        const AP_COLOR = "#facc15";
        const FC_COLOR = "#22c55e";

        const DIFFICULTY_CONFIG = {
            classic: { label: "Classic", targetNpm: 45, densifyLevel: 0 },
            expert: { label: "Expert", targetNpm: 75, densifyLevel: 1 },
            master: { label: "Master", targetNpm: 110, densifyLevel: 2 },
            legendary: { label: "Legendary", targetNpm: 150, densifyLevel: 3 }
        };

        const gameState = {
            audioCtx: null,
            buffer: null,
            source: null,
            startTime: 0,
            mode: "idle",
            isPaused: false,
            pausedAt: 0,
            approachTime: 1.2,
            notes: [],
            totalNotes: 0,
            totalWeight: 1,
            scoreValue: 0,
            combo: 0,
            maxCombo: 0,
            perfectCount: 0,
            goodCount: 0,
            badCount: 0,
            missCount: 0,
            currentScorePercent: 0,
            currentGrade: "D",
            currentGradeLevel: 0,
            lastJudgement: "",
            lastJudgementTime: 0,
            hitEffects: [],
            bgCircles: [],
            bgRays: [],
            lastBeats: [],
            lastBeatPeriod: 0.5,
            hitOffsets: [],
            currentSongName: "Unknown Track",
            difficulty: "classic",
            baseSeed: 1,
            rng: null,
            demoCursor: {
                active: false,
                x: canvas.width / 2,
                y: canvas.height / 2,
                targetX: canvas.width / 2,
                targetY: canvas.height / 2,
                rotation: 0,
                trail: []
            },
            playerCursor: {
                active: false,
                x: canvas.width / 2,
                y: canvas.height / 2,
                rotation: 0,
                trail: []
            },
            actualNpm: 0
        };

        exportScoreBtn.disabled = true;

        canvas.addEventListener("pointerdown", (e) => {
            e.preventDefault();
            if (gameState.audioCtx && gameState.audioCtx.state === "suspended") {
                gameState.audioCtx.resume();
            }
            handleTapScreen(e.clientX, e.clientY);
        });

        canvas.addEventListener("pointermove", (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            const cur = gameState.playerCursor;
            cur.x = x;
            cur.y = y;
            cur.active = true;
            if (cur.trail) {
                cur.trail.push({ x, y });
                if (cur.trail.length > 22) cur.trail.shift();
            }
        });

        canvas.addEventListener("touchstart", (e) => {
            e.preventDefault();
            if (gameState.audioCtx && gameState.audioCtx.state === "suspended") {
                gameState.audioCtx.resume();
            }
            const touch = e.changedTouches[0];
            if (!touch) return;
            handleTapScreen(touch.clientX, touch.clientY);
        }, { passive: false });

        function resizeCanvas() {
            const scale = Math.min(window.innerWidth / 1000, window.innerHeight / 650, 1);
            canvas.style.transformOrigin = "top center";
            canvas.style.transform = `scale(${scale})`;
        }
        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();

        function initBackground() {
            gameState.bgCircles = [];
            for (let i = 0; i < 24; i++) {
                gameState.bgCircles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    r: 20 + Math.random() * 80,
                    speed: 0.2 + Math.random() * 0.6,
                    alpha: 0.04 + Math.random() * 0.08
                });
            }

            gameState.bgRays = [];
            const rayCount = 18;
            for (let i = 0; i < rayCount; i++) {
                gameState.bgRays.push({
                    angle: (i / rayCount) * Math.PI * 2,
                    width: 0.012 + Math.random() * 0.02,
                    speed: (0.1 + Math.random() * 0.15) * (Math.random() < 0.5 ? 1 : -1),
                    alpha: 0.04 + Math.random() * 0.07
                });
            }
        }
        initBackground();

        function drawBackground(deltaTime) {
            ctx.save();
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const maxR = Math.hypot(cx, cy);

            const radialGrad = ctx.createRadialGradient(
                cx, cy, 0,
                cx, cy, maxR
            );
            radialGrad.addColorStop(0, "rgba(15,23,42,1)");
            radialGrad.addColorStop(0.4, "rgba(15,23,42,0.95)");
            radialGrad.addColorStop(1, "rgba(2,6,23,1)");
            ctx.fillStyle = radialGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (const ray of gameState.bgRays) {
                ray.angle += ray.speed * deltaTime;
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(ray.angle);
                const rayGrad = ctx.createLinearGradient(0, 0, maxR, 0);
                rayGrad.addColorStop(0, `rgba(59,130,246,${ray.alpha})`);
                rayGrad.addColorStop(0.4, `rgba(236,72,153,${ray.alpha * 0.8})`);
                rayGrad.addColorStop(1, "rgba(15,23,42,0)");
                ctx.fillStyle = rayGrad;
                const width = maxR * ray.width;
                ctx.beginPath();
                ctx.moveTo(0, -width);
                ctx.lineTo(maxR, -width * 0.3);
                ctx.lineTo(maxR, width * 0.3);
                ctx.lineTo(0, width);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            for (const c of gameState.bgCircles) {
                c.y -= c.speed * deltaTime * 60;
                if (c.y + c.r < 0) {
                    c.y = canvas.height + c.r;
                    c.x = Math.random() * canvas.width;
                }
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(148,163,184,${c.alpha})`;
                ctx.fill();
            }

            ctx.restore();
        }

        function enterFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                return elem.requestFullscreen().catch(() => { });
            } else if (elem.webkitRequestFullscreen) {
                return elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) {
                return elem.msRequestFullscreen();
            }
        }

        function exitFullscreen() {
            const doc = document;
            if (
                doc.fullscreenElement ||
                doc.webkitFullscreenElement ||
                doc.msFullscreenElement
            ) {
                if (doc.exitFullscreen) {
                    doc.exitFullscreen();
                } else if (doc.webkitExitFullscreen) {
                    doc.webkitExitFullscreen();
                } else if (doc.msExitFullscreen) {
                    doc.msExitFullscreen();
                }
            }
        }

        function enterGameplayScreen() {
            document.body.style.overflow = "hidden";
            document.querySelector("h1").style.display = "none";
            document.querySelector(".panel").style.display = "none";
            document.getElementById("songTitle").style.display = "none";
            document.querySelector(".info").style.display = "none";
            document.querySelector(".stats").style.display = "none";
            document.querySelector(".judge-stats").style.display = "none";
            document.querySelector(".hint").style.display = "none";
            offsetStatsEl.style.display = "none";
            document.querySelector(".footer").style.display = "none";
            document.getElementById("gameContainer").classList.add("fullscreen-play");
            startBtn.style.display = "none";
            canvas.style.cursor = "none";
        }

        function exitGameplayScreen() {
            document.body.style.overflow = "auto";
            document.querySelector("h1").style.display = "";
            document.querySelector(".panel").style.display = "";
            document.getElementById("songTitle").style.display = "";
            document.querySelector(".info").style.display = "";
            document.querySelector(".stats").style.display = "";
            document.querySelector(".judge-stats").style.display = "";
            document.querySelector(".hint").style.display = "";
            offsetStatsEl.style.display = "";
            document.querySelector(".footer").style.display = "";
            document.getElementById("gameContainer").classList.remove("fullscreen-play");
            startBtn.style.display = "";
            canvas.style.cursor = "";
        }

        function stringHash(str) {
            let h = 0;
            for (let i = 0; i < str.length; i++) {
                h = (h * 31 + str.charCodeAt(i)) | 0;
            }
            return h >>> 0;
        }

        function createRNG(seed) {
            let s = seed >>> 0;
            return function () {
                s = (s * 1664525 + 1013904223) >>> 0;
                return (s >>> 0) / 4294967296;
            };
        }

        function initDeterministicSeed() {
            const name = gameState.currentSongName || "Unknown";
            let h = stringHash(name);
            if (gameState.buffer) {
                h = (h * 31 + Math.floor(gameState.buffer.duration * 1000)) | 0;
            }
            gameState.baseSeed = (h ^ 0x9e3779b9) >>> 0;
        }

        function makeChartRNG(offset) {
            const diff = gameState.difficulty || "classic";
            const idxMap = { classic: 1, expert: 2, master: 3, legendary: 4 };
            const d = idxMap[diff] || 1;
            const seed = (gameState.baseSeed + d * 10007 + (offset || 0)) >>> 0;
            gameState.rng = createRNG(seed);
            return gameState.rng;
        }

        function stopCurrentSource() {
            if (gameState.source) {
                try { gameState.source.stop(); } catch { }
                gameState.source = null;
            }
        }

        fileInput.addEventListener("change", async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            stopCurrentSource();
            gameState.mode = "idle";
            startBtn.disabled = true;
            exportScoreBtn.disabled = true;
            judgementTextEl.textContent = "";
            infoText.textContent = "正在解码音频并进行频域分析，请稍等几秒...";

            const nameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
            gameState.currentSongName = nameWithoutExt || "Unknown Track";
            songTitleEl.textContent = "当前乐曲：" + gameState.currentSongName;

            try {
                const arrayBuffer = await file.arrayBuffer();
                if (!gameState.audioCtx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    gameState.audioCtx = new AC();
                }
                const audioCtx = gameState.audioCtx;
                gameState.buffer = await audioCtx.decodeAudioData(arrayBuffer);

                initDeterministicSeed();
                const rngBeat = makeChartRNG(0);
                infoText.textContent = "基于多频段谱通量 + BPM + pattern 生成谱面中...";
                const { beats, beatPeriod } = generateBeatTimes(gameState.buffer, rngBeat);

                gameState.lastBeats = beats;
                gameState.lastBeatPeriod = beatPeriod || 0.5;

                if (beats.length === 0) {
                    infoText.textContent = "节拍检测结果为空，可能是比较平的背景音。你仍可点“开始游戏”体验一下。";
                }

                regenerateNotesFromCachedBeats();
                startBtn.disabled = false;
                exportScoreBtn.disabled = false;
            } catch (err) {
                console.error(err);
                infoText.textContent = "音频解码失败，请尝试换一首 mp3。";
            }
        });

        useExampleBtn.addEventListener("click", async () => {
            try {
                stopCurrentSource();
                gameState.mode = "idle";
                startBtn.disabled = true;
                exportScoreBtn.disabled = true;
                infoText.textContent = "正在加载示例 mp3...";

                if (!gameState.audioCtx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    gameState.audioCtx = new AC();
                }
                const res = await fetch(EXAMPLE_MP3_URL);
                const arrayBuffer = await res.arrayBuffer();
                const buffer = await gameState.audioCtx.decodeAudioData(arrayBuffer);
                gameState.buffer = buffer;

                const urlName = EXAMPLE_MP3_URL.split("/").pop() || "示例歌曲";
                const baseName = urlName.replace(/\.[^/.]+$/, "");
                gameState.currentSongName = baseName || "示例歌曲";
                songTitleEl.textContent = "当前乐曲：" + gameState.currentSongName;

                gameState.difficulty = "legendary";
                difficultySelect.value = "legendary";

                initDeterministicSeed();
                const rngBeat = makeChartRNG(0);

                infoText.textContent = "基于示例歌曲生成谱面中...";
                const { beats, beatPeriod } = generateBeatTimes(buffer, rngBeat);

                gameState.lastBeats = beats;
                gameState.lastBeatPeriod = beatPeriod || 0.5;

                if (beats.length === 0) {
                    infoText.textContent = "节拍检测结果为空，可能是比较平的背景音。你仍可点“开始游戏”体验一下。";
                }

                regenerateNotesFromCachedBeats();
                startBtn.disabled = false;
                exportScoreBtn.disabled = false;

                startDemoPreview();
            } catch (err) {
                console.error(err);
                infoText.textContent = "示例音频加载失败，请确认 example.mp3 是否放在同目录下。";
            }
        });

        difficultySelect.addEventListener("change", () => {
            gameState.difficulty = difficultySelect.value;
            regenerateNotesFromCachedBeats();
        });

        function regenerateNotesFromCachedBeats() {
            if (!gameState.buffer || !gameState.lastBeats.length) {
                gameState.notes = [];
                noteCountEl.textContent = "0";
                npmEl.textContent = "0.0";
                return;
            }
            const rngNotes = makeChartRNG(1);
            prepareNotes(gameState.lastBeats, gameState.lastBeatPeriod, gameState.buffer, rngNotes);
            gameState.totalNotes = gameState.notes.length;
            noteCountEl.textContent = gameState.totalNotes;
            updateNPM();
            resetScoreState();
        }

        function generateBeatTimes(buffer, rngFn) {
            const rng = rngFn || Math.random;
            const channelData = buffer.getChannelData(0);
            const sampleRate = buffer.sampleRate;

            const maxSecondsForAnalysis = 99999;
            const maxSamples = Math.min(channelData.length, maxSecondsForAnalysis * sampleRate);

            const frameSize = 2048;
            const hopSize = 1024;

            const bandFreqs = [80, 120, 200, 350, 600, 1000, 2000, 3500];
            const bandWeights = [2.0, 2.0, 1.6, 1.3, 1.0, 0.8, 0.6, 0.4];

            const numFrames = Math.floor((maxSamples - frameSize) / hopSize);
            if (numFrames <= 0) return { beats: [], beatPeriod: 0.5 };

            const flux = new Array(numFrames).fill(0);
            let prevMagnitudes = new Array(bandFreqs.length).fill(0);

            function goertzel(frame, offset, N, freq, sr) {
                const k = Math.round(0.5 + ((N * freq) / sr));
                const omega = (2 * Math.PI * k) / N;
                const cos = Math.cos(omega);
                const sin = Math.sin(omega);
                const coeff = 2 * cos;
                let q0 = 0, q1 = 0, q2 = 0;
                for (let i = 0; i < N; i++) {
                    q0 = coeff * q1 - q2 + frame[offset + i];
                    q2 = q1;
                    q1 = q0;
                }
                const real = q1 - q2 * cos;
                const imag = q2 * sin;
                return Math.sqrt(real * real + imag * imag);
            }

            for (let f = 0; f < numFrames; f++) {
                const offset = f * hopSize;
                const mags = [];
                for (let b = 0; b < bandFreqs.length; b++) {
                    const mag = goertzel(channelData, offset, frameSize, bandFreqs[b], sampleRate);
                    mags.push(mag);
                }
                let fluxValue = 0;
                for (let i = 0; i < mags.length; i++) {
                    const diff = mags[i] - prevMagnitudes[i];
                    if (diff > 0) fluxValue += diff * bandWeights[i];
                }
                flux[f] = fluxValue;
                prevMagnitudes = mags;
            }

            const smoothed = [];
            const smoothSize = 4;
            let maxFlux = 0;
            for (let i = 0; i < flux.length; i++) {
                let sum = 0, count = 0;
                for (let j = -smoothSize; j <= smoothSize; j++) {
                    const idx = i + j;
                    if (idx >= 0 && idx < flux.length) {
                        sum += flux[idx];
                        count++;
                    }
                }
                const v = count ? sum / count : 0;
                smoothed.push(v);
                if (v > maxFlux) maxFlux = v;
            }
            if (maxFlux <= 0) return { beats: [], beatPeriod: 0.5 };
            for (let i = 0; i < smoothed.length; i++) {
                smoothed[i] /= maxFlux;
            }

            const framesPerSecond = sampleRate / hopSize;

            const minTempo = 60;
            const maxTempo = 200;
            const minLag = Math.round(framesPerSecond * 60 / maxTempo);
            const maxLag = Math.round(framesPerSecond * 60 / minTempo);

            let bestLag = null;
            let bestScore = -Infinity;
            for (let lag = minLag; lag <= maxLag; lag++) {
                let score = 0;
                for (let i = 0; i + lag < smoothed.length; i++) {
                    score += smoothed[i] * smoothed[i + lag];
                }
                if (score > bestScore) {
                    bestScore = score;
                    bestLag = lag;
                }
            }
            if (!bestLag) return { beats: [], beatPeriod: 0.5 };

            let beatPeriod = bestLag / framesPerSecond;
            beatPeriod = Math.min(Math.max(beatPeriod, 0.25), 1.0);

            const beatWindow = beatPeriod * 0.25;
            const phaseStep = beatPeriod / 32;
            let bestPhase = 0;
            let bestPhaseScore = -Infinity;

            for (let phase = 0; phase < beatPeriod; phase += phaseStep) {
                let score = 0;
                for (let i = 0; i < smoothed.length; i++) {
                    const t = i / framesPerSecond;
                    const n = Math.round((t - phase) / beatPeriod);
                    const beatTime = phase + n * beatPeriod;
                    if (beatTime < 0) continue;
                    const dist = Math.abs(t - beatTime);
                    if (dist <= beatWindow) {
                        const w = 1 - dist / beatWindow;
                        score += smoothed[i] * w;
                    }
                }
                if (score > bestPhaseScore) {
                    bestPhaseScore = score;
                    bestPhase = phase;
                }
            }

            const duration = Math.min(buffer.duration, maxSecondsForAnalysis);
            const measureDuration = beatPeriod * 4;
            let firstMeasureStart = bestPhase;
            while (firstMeasureStart < 0) firstMeasureStart += measureDuration;
            if (firstMeasureStart > duration) firstMeasureStart = 0;

            const numMeasures = Math.max(
                1,
                Math.floor((duration - firstMeasureStart) / measureDuration)
            );

            const patterns = {
                low: [
                    [1, 0, 0, 0, 0, 0, 1, 0],
                    [1, 0, 0, 1, 0, 0, 1, 0],
                    [1, 0, 1, 0, 0, 0, 1, 0],
                ],
                mid: [
                    [1, 0, 0, 0, 1, 0, 1, 0],
                    [1, 0, 1, 0, 1, 0, 0, 1],
                    [1, 0, 1, 0, 1, 0, 1, 0],
                    [1, 0, 1, 1, 0, 0, 1, 0],
                ],
                high: [
                    [1, 1, 0, 1, 1, 0, 1, 0],
                    [1, 1, 0, 1, 1, 1, 1, 0],
                    [1, 0, 1, 1, 1, 0, 1, 1],
                    [1, 1, 1, 0, 1, 1, 0, 1],
                ]
            };

            const beats = [];
            const maxNotes = 99999;

            function snapToLocalPeak(timeSeconds) {
                const searchRadius = beatPeriod * 0.2;
                const startT = Math.max(0, timeSeconds - searchRadius);
                const endT = Math.min(duration, timeSeconds + searchRadius);

                const startIndex = Math.max(0, Math.floor(startT * framesPerSecond));
                const endIndex = Math.min(smoothed.length - 1, Math.ceil(endT * framesPerSecond));

                let bestIdx = null;
                let bestVal = -Infinity;
                for (let i = startIndex; i <= endIndex; i++) {
                    const v = smoothed[i];
                    if (v > bestVal) {
                        bestVal = v;
                        bestIdx = i;
                    }
                }
                if (bestIdx == null) return timeSeconds;
                return bestIdx / framesPerSecond;
            }

            for (let m = 0; m < numMeasures; m++) {
                const measureStart = firstMeasureStart + m * measureDuration;
                const measureEnd = measureStart + measureDuration;
                if (measureStart >= duration) break;

                let sum = 0, count = 0;
                const startIndex = Math.max(0, Math.floor(measureStart * framesPerSecond));
                const endIndex = Math.min(smoothed.length - 1, Math.ceil(measureEnd * framesPerSecond));
                for (let i = startIndex; i <= endIndex; i++) {
                    sum += smoothed[i];
                    count++;
                }
                const intensity = count ? sum / count : 0;

                let bucket = "mid";
                if (intensity < 0.25) bucket = "low";
                else if (intensity > 0.6) bucket = "high";

                const bucketPatterns = patterns[bucket];
                const pattern = bucketPatterns[Math.floor((rng() || 0) * bucketPatterns.length)];

                for (let s = 0; s < pattern.length; s++) {
                    if (!pattern[s]) continue;

                    const slotOffset = (beatPeriod / 2) * s;
                    let t = measureStart + slotOffset;
                    if (t < 0 || t > duration) continue;

                    const tFrame = Math.round(t * framesPerSecond);
                    const radiusFrames = Math.round(beatWindow * framesPerSecond);
                    let localSum = 0, localCount = 0;
                    for (let k = -radiusFrames; k <= radiusFrames; k++) {
                        const idx = tFrame + k;
                        if (idx >= 0 && idx < smoothed.length) {
                            localSum += smoothed[idx];
                            localCount++;
                        }
                    }
                    const localAvg = localCount ? localSum / localCount : 0;

                    if (localAvg < 0.4) {
                        continue;
                    }

                    const snappedTime = snapToLocalPeak(t);
                    beats.push(snappedTime);
                    if (beats.length >= maxNotes) break;
                }
                if (beats.length >= maxNotes) break;
            }

            if (beats.length === 0) {
                const fallbackBeats = [];
                const durationSafe = Math.min(buffer.duration, maxSecondsForAnalysis);
                for (let t = 0; t < durationSafe; t += beatPeriod) {
                    fallbackBeats.push(t);
                    if (fallbackBeats.length >= maxNotes) break;
                }
                return { beats: fallbackBeats, beatPeriod };
            }

            beats.sort((a, b) => a - b);
            const merged = [];
            const minGap = 0.02;
            for (let i = 0; i < beats.length; i++) {
                if (i === 0 || beats[i] - merged[merged.length - 1] > minGap) {
                    merged.push(beats[i]);
                }
            }
            return { beats: merged, beatPeriod };
        }

        function buildDenseBeats(baseBeats, beatPeriod, level) {
            if (level <= 0) return baseBeats.slice();
            let current = baseBeats.slice();
            for (let iter = 0; iter < level; iter++) {
                const extra = [];
                for (let i = 0; i < current.length - 1; i++) {
                    const t1 = current[i];
                    const t2 = current[i + 1];
                    const gap = t2 - t1;
                    if (gap > beatPeriod * 0.35 && gap < beatPeriod * 2.4) {
                        extra.push(t1 + gap * 0.5);
                    }
                }
                current = current.concat(extra);
                current.sort((a, b) => a - b);

                const merged = [];
                const minGap = beatPeriod * 0.16;
                for (let i = 0; i < current.length; i++) {
                    if (i === 0 || current[i] - merged[merged.length - 1] > minGap) {
                        merged.push(current[i]);
                    }
                }
                current = merged;
            }
            return current;
        }

        function selectBeats(baseBeats, beatPeriod, durationSec) {
            if (!baseBeats.length) return [];
            const diffKey = gameState.difficulty || "classic";
            const conf = DIFFICULTY_CONFIG[diffKey] || DIFFICULTY_CONFIG.classic;

            const dense = buildDenseBeats(baseBeats, beatPeriod, conf.densifyLevel);
            const durationMin = Math.max(durationSec / 60, 0.1);
            const targetNpm = conf.targetNpm;
            let targetCount = Math.floor(targetNpm * durationMin);
            if (!targetCount) targetCount = Math.min(baseBeats.length, dense.length);

            const maxTarget = baseBeats.length * (1 + conf.densifyLevel * 1.2) * 2;
            targetCount = Math.min(targetCount, dense.length, maxTarget);

            let source = dense;
            if (source.length > targetCount && targetCount > 0) {
                const selected = [];
                const step = source.length / targetCount;
                for (let i = 0; i < targetCount; i++) {
                    const idx = Math.floor(i * step);
                    if (idx >= 0 && idx < source.length) selected.push(source[idx]);
                }
                source = selected;
            }

            const result = [];
            let lastT = -Infinity;
            const minGap = Math.max(0.08, beatPeriod * 0.16);
            for (let i = 0; i < source.length; i++) {
                const t = source[i];
                if (t - lastT >= minGap) {
                    result.push(t);
                    lastT = t;
                }
            }
            return result;
        }

        function fillLongSilences(times, beatPeriod, durationSec) {
            if (!times.length) return [];
            const sorted = times.slice().sort((a, b) => a - b);
            const result = [];
            const maxGap = Math.max(beatPeriod * 4, 2.0);

            let last = sorted[0];
            result.push(last);
            for (let i = 1; i < sorted.length; i++) {
                const t = sorted[i];
                const gap = t - last;
                if (gap > maxGap) {
                    const extraCount = Math.floor(gap / maxGap);
                    for (let k = 1; k <= extraCount; k++) {
                        const tt = last + (gap * k) / (extraCount + 1);
                        result.push(tt);
                    }
                }
                result.push(t);
                last = t;
            }
            return result.sort((a, b) => a - b);
        }

        function chooseNotePosition(lastPos, prevPrevPos, margin, rng) {
            const rand = rng || Math.random;
            const width = canvas.width;
            const height = canvas.height;
            const left = margin;
            const right = width - margin;
            const top = margin;
            const bottom = height - margin;

            if (!lastPos) {
                return {
                    x: left + rand() * (right - left),
                    y: top + rand() * (bottom - top),
                };
            }

            const maxAttempts = 16;
            let attempt = 0;
            let chosen = null;

            while (attempt < maxAttempts) {
                let minStep = 110;
                let maxStep = 220;
                const angle = rand() * Math.PI * 2;
                const step = minStep + rand() * (maxStep - minStep);
                let x = lastPos.x + Math.cos(angle) * step;
                let y = lastPos.y + Math.sin(angle) * step;

                x = Math.min(right, Math.max(left, x));
                y = Math.min(bottom, Math.max(top, y));
                const candidate = { x, y };

                if (prevPrevPos) {
                    const v1x = lastPos.x - prevPrevPos.x;
                    const v1y = lastPos.y - prevPrevPos.y;
                    const v2x = candidate.x - lastPos.x;
                    const v2y = candidate.y - lastPos.y;
                    const len1 = Math.hypot(v1x, v1y) || 1;
                    const len2 = Math.hypot(v2x, v2y) || 1;
                    const cos = (v1x * v2x + v1y * v2y) / (len1 * len2);
                    const clampedCos = Math.max(-1, Math.min(1, cos));
                    const angleBetween = Math.acos(clampedCos);
                    const minAngleRad = 25 * Math.PI / 180;
                    if (angleBetween < minAngleRad) {
                        attempt++;
                        continue;
                    }
                }

                chosen = candidate;
                break;
            }

            if (!chosen) {
                chosen = lastPos;
            }
            return chosen;
        }

        function applyFixedPatterns(positions, margin, rng) {
            const rand = rng || Math.random;
            const n = positions.length;
            if (n < 3) return;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            let i = 0;
            while (i < n - 2) {
                if (rand() > 0.18) {
                    i++;
                    continue;
                }
                const remain = n - i;
                const rBase = Math.min(canvas.width, canvas.height) / 3;
                const baseRadius = rBase * (0.7 + rand() * 0.3);
                const baseAngle = rand() * Math.PI * 2;
                const pRoll = rand();

                if (pRoll < 0.25 && remain >= 3) {
                    const step = 2 * Math.PI / 3;
                    for (let k = 0; k < 3; k++) {
                        const angle = baseAngle + k * step;
                        positions[i + k] = {
                            x: cx + Math.cos(angle) * baseRadius,
                            y: cy + Math.sin(angle) * baseRadius
                        };
                    }
                    i += 3;
                } else if (pRoll < 0.5 && remain >= 4) {
                    const step = Math.PI / 2;
                    const r = baseRadius * 0.9;
                    for (let k = 0; k < 4; k++) {
                        const angle = baseAngle + k * step;
                        positions[i + k] = {
                            x: cx + Math.cos(angle) * r,
                            y: cy + Math.sin(angle) * r
                        };
                    }
                    i += 4;
                } else if (pRoll < 0.7 && remain >= 6) {
                    const step = Math.PI / 3;
                    const r = baseRadius;
                    for (let k = 0; k < 6; k++) {
                        const angle = baseAngle + k * step;
                        positions[i + k] = {
                            x: cx + Math.cos(angle) * r,
                            y: cy + Math.sin(angle) * r
                        };
                    }
                    i += 6;
                } else if (pRoll < 0.85 && remain >= 2) {
                    const basePos = positions[i] || {
                        x: cx + Math.cos(baseAngle) * baseRadius,
                        y: cy + Math.sin(baseAngle) * baseRadius
                    };
                    positions[i] = basePos;
                    positions[i + 1] = { x: basePos.x, y: basePos.y };
                    i += 2;
                } else if (remain >= 4) {
                    const r = baseRadius;
                    const a1 = baseAngle;
                    const a2 = baseAngle + Math.PI / 2;
                    const p0 = { x: cx + Math.cos(a1) * r, y: cy + Math.sin(a1) * r };
                    const p1 = { x: cx + Math.cos(a2) * r, y: cy + Math.sin(a2) * r };
                    const p2 = { x: 2 * cx - p0.x, y: 2 * cy - p0.y };
                    const p3 = { x: 2 * cx - p1.x, y: 2 * cy - p1.y };
                    positions[i] = p0;
                    positions[i + 1] = p1;
                    positions[i + 2] = p2;
                    positions[i + 3] = p3;
                    i += 4;
                } else {
                    i++;
                }
            }

            const width = canvas.width;
            const height = canvas.height;
            const left = margin;
            const right = width - margin;
            const top = margin;
            const bottom = height - margin;
            for (let j = 0; j < positions.length; j++) {
                const p = positions[j];
                if (!p) continue;
                p.x = Math.min(right, Math.max(left, p.x));
                p.y = Math.min(bottom, Math.max(top, p.y));
            }
        }

        function enforceNoTripleStack(positions, margin, rng) {
            for (let i = 2; i < positions.length; i++) {
                const p0 = positions[i - 2];
                const p1 = positions[i - 1];
                const p2 = positions[i];
                if (!p0 || !p1 || !p2) continue;
                const d01 = Math.hypot(p0.x - p1.x, p0.y - p1.y);
                const d12 = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                const tolerance = 4;
                if (d01 < tolerance && d12 < tolerance) {
                    positions[i] = chooseNotePosition(p1, p0, margin, rng);
                }
            }
        }

        function prepareNotes(beats, beatPeriod, buffer, rngFn) {
            const rng = rngFn || Math.random;

            let times = selectBeats(beats, beatPeriod, buffer.duration);
            times = fillLongSilences(times, beatPeriod, buffer.duration);

            if (times.length) {
                let earliest = times[0];
                for (const t of times) {
                    if (t < earliest) earliest = t;
                }
                if (earliest < SAFE_LEAD_IN) {
                    const shift = SAFE_LEAD_IN - earliest;
                    times = times.map(t => t + shift);
                }
            }

            gameState.notes = [];

            const margin = 110;
            const baseRadius = 40;
            const approach = gameState.approachTime;

            const positions = [];
            let lastPos = null;
            let prevPrevPos = null;

            for (let i = 0; i < times.length; i++) {
                const pos = chooseNotePosition(lastPos, prevPrevPos, margin, rng);
                positions.push(pos);
                prevPrevPos = lastPos;
                lastPos = pos;
            }

            applyFixedPatterns(positions, margin, rng);
            enforceNoTripleStack(positions, margin, rng);

            let prevNote = null;
            for (let i = 0; i < times.length; i++) {
                const t = times[i];
                let spawnTime = t - approach;
                if (spawnTime < 0) spawnTime = 0;
                const pos = positions[i];

                const angle = (rng() || 0) * Math.PI * 2;
                const distance = Math.max(canvas.width, canvas.height) * 0.7;
                const spawnX = pos.x + Math.cos(angle) * distance;
                const spawnY = pos.y + Math.sin(angle) * distance;
                const radius = baseRadius * (0.9 + (rng() || 0) * 0.3);

                const note = {
                    targetTime: t,
                    spawnTime,
                    x: pos.x,
                    y: pos.y,
                    radius,
                    spawnX,
                    spawnY,
                    hit: false,
                    hitFly: false,
                    hitStartTime: null,
                    hitVX: 0,
                    hitVY: 0,
                    missed: false,
                    missStartTime: null,
                    missVX: 0,
                    missVY: 0,
                    rotation: (rng() || 0) * Math.PI * 2,
                    rotationSpeed: ((rng() || 0) * 2 - 1) * 1.5,
                    trail: [],
                    prevOutline: prevNote,
                    isGold: false,
                    weight: 1,
                    gone: false
                };

                gameState.notes.push(note);
                prevNote = note;
            }

            const n = gameState.notes.length;
            if (n > 0) {
                const goldRatio = 0.12;
                const goldTarget = Math.max(1, Math.round(n * goldRatio));
                const indices = [...Array(n).keys()];
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor((rng() || 0) * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }
                for (let i = 0; i < goldTarget && i < indices.length; i++) {
                    const idx = indices[i];
                    gameState.notes[idx].isGold = true;
                    gameState.notes[idx].weight = 3;
                }
            }

            gameState.notes.sort((a, b) => a.targetTime - b.targetTime);

            let totalWeight = 0;
            for (const nNote of gameState.notes) {
                totalWeight += nNote.weight || 1;
            }
            gameState.totalWeight = totalWeight || 1;
        }

        function updateNPM() {
            if (!npmEl) return;
            if (!gameState.notes.length) {
                npmEl.textContent = "0.0";
                gameState.actualNpm = 0;
                return;
            }
            let first = gameState.notes[0].targetTime;
            let last = gameState.notes[gameState.notes.length - 1].targetTime;
            if (!(first < last)) {
                if (gameState.buffer && gameState.buffer.duration) {
                    first = 0;
                    last = gameState.buffer.duration;
                } else {
                    npmEl.textContent = "0.0";
                    gameState.actualNpm = 0;
                    return;
                }
            }
            const effectiveDuration = Math.max(last - first, 1);
            const total = gameState.notes.length;
            const npm = total / (effectiveDuration / 60);
            gameState.actualNpm = npm;
            npmEl.textContent = npm.toFixed(1);

            const diffConf = DIFFICULTY_CONFIG[gameState.difficulty] || DIFFICULTY_CONFIG.classic;
            if (infoText && gameState.buffer) {
                infoText.textContent =
                    `已生成谱面：难度 ${diffConf.label}，音符 ${total} 个，` +
                    `实际密度约 ${npm.toFixed(1)} NPM（目标 ${diffConf.targetNpm} NPM）`;
            }
        }

        function resetScoreState() {
            gameState.scoreValue = 0;
            gameState.combo = 0;
            gameState.maxCombo = 0;
            gameState.perfectCount = 0;
            gameState.goodCount = 0;
            gameState.badCount = 0;
            gameState.missCount = 0;
            gameState.currentScorePercent = 0;
            gameState.currentGrade = "D";
            gameState.currentGradeLevel = 0;
            gameState.lastJudgement = "";
            gameState.hitEffects = [];
            gameState.hitOffsets = [];
            judgementTextEl.textContent = "";
            judgementTextEl.style.transform = "scale(1)";
            if (offsetStatsEl) offsetStatsEl.textContent = "";
            updateScoreAndUI();
        }

        function showPauseMenu() {
            pauseSongTitle.textContent = "当前乐曲：" + (gameState.currentSongName || "-");
            pauseOverlay.style.display = "flex";
        }

        function hidePauseMenu() {
            pauseOverlay.style.display = "none";
        }

        function showResultScreen() {
            const diffConf = DIFFICULTY_CONFIG[gameState.difficulty] || DIFFICULTY_CONFIG.classic;
            const gradeInfo = getGradeFromPercent(gameState.currentScorePercent);
            const gradeLabel = gradeInfo.label;
            const clearType = getClearType();

            resultSongTitle.textContent = "乐曲：" + (gameState.currentSongName || "-");
            resultGradeEl.textContent = gradeLabel;
            resultScoreEl.textContent = gameState.currentScorePercent.toFixed(4) + "%";

            if (clearType === "AP") {
                resultClearEl.textContent = "ALL PERFECT";
                resultClearEl.style.color = AP_COLOR;
            } else if (clearType === "FC") {
                resultClearEl.textContent = "FULL COMBO";
                resultClearEl.style.color = FC_COLOR;
            } else {
                resultClearEl.textContent = "";
                resultClearEl.style.color = "#e5e7eb";
            }

            resultDifficultyEl.textContent = "难度：" + diffConf.label;
            resultNpmEl.textContent = "密度：" + gameState.actualNpm.toFixed(1) + " NPM";

            resultStatsEl.innerHTML =
                `Max Combo: ${gameState.maxCombo}<br>` +
                `PERFECT: ${gameState.perfectCount} · GOOD: ${gameState.goodCount} · BAD: ${gameState.badCount} · MISS: ${gameState.missCount} · Notes: ${gameState.totalNotes}`;

            applyGradeColor(gradeLabel, resultGradeEl, resultScoreEl);

            hidePauseMenu();
            resultOverlay.style.display = "flex";
        }

        function hideResultScreen() {
            resultOverlay.style.display = "none";
        }

        function pauseGame() {
            if (gameState.mode !== "playing" || !gameState.audioCtx || gameState.isPaused) return;
            gameState.isPaused = true;
            if (gameState.buffer) {
                gameState.pausedAt = gameState.audioCtx.currentTime - gameState.startTime;
            } else {
                gameState.pausedAt = 0;
            }
            stopCurrentSource();
            showPauseMenu();
        }

        function resumeGame() {
            if (gameState.mode !== "playing" || !gameState.audioCtx || !gameState.buffer || !gameState.isPaused) return;
            const audioCtx = gameState.audioCtx;
            const offset = Math.max(0, gameState.pausedAt || 0);
            const source = audioCtx.createBufferSource();
            source.buffer = gameState.buffer;
            source.connect(audioCtx.destination);
            source.start(0, offset);
            gameState.source = source;
            gameState.startTime = audioCtx.currentTime - offset;
            gameState.isPaused = false;
            hidePauseMenu();
        }

        function retryGame() {
            if (!gameState.audioCtx || !gameState.buffer) return;
            hidePauseMenu();
            hideResultScreen();
            gameState.mode = "playing";
            gameState.isPaused = false;
            gameState.pausedAt = 0;
            startGame();
        }

        function quitGame() {
            hidePauseMenu();
            hideResultScreen();
            stopCurrentSource();
            gameState.mode = "idle";
            gameState.isPaused = false;
            gameState.pausedAt = 0;
            exitGameplayScreen();
            exitFullscreen();
            infoText.textContent = "已退出游戏。可以重新选择歌曲或开始新的游戏。";
        }

        resumeBtn.addEventListener("click", resumeGame);
        retryBtn.addEventListener("click", retryGame);
        quitBtn.addEventListener("click", quitGame);

        resultRetryBtn.addEventListener("click", retryGame);
        resultExitBtn.addEventListener("click", quitGame);
        resultExportBtn.addEventListener("click", exportScoreImage);

        startBtn.addEventListener("click", async () => {
            if (!gameState.buffer || !gameState.audioCtx) return;
            stopCurrentSource();
            enterGameplayScreen();
            await enterFullscreen();
            gameState.mode = "playing";
            startGame();
        });

        window.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
                if (gameState.mode === "playing") {
                    if (!gameState.isPaused) pauseGame();
                    else resumeGame();
                }
                return;
            }

            const ignoreKeys = ["Shift", "Control", "Alt", "Meta", "CapsLock", "Tab"];
            if (ignoreKeys.includes(e.key)) return;

            if (gameState.mode === "idle" && !startBtn.disabled && gameState.buffer) {
                // 在大厅按任意键也可以开始
                startBtn.click();
                return;
            }

            if (gameState.mode !== "playing" || gameState.isPaused || !gameState.audioCtx) return;
            e.preventDefault();
            handleHit();
        });

        function startGame() {
            const audioCtx = gameState.audioCtx;
            if (!audioCtx || !gameState.buffer) return;

            stopCurrentSource();
            const source = audioCtx.createBufferSource();
            source.buffer = gameState.buffer;
            source.connect(audioCtx.destination);
            source.start(0, 0);

            gameState.source = source;
            gameState.startTime = audioCtx.currentTime;
            gameState.mode = "playing";
            gameState.isPaused = false;
            gameState.pausedAt = 0;

            resetScoreState();
            for (const n of gameState.notes) {
                n.hit = false;
                n.hitFly = false;
                n.hitStartTime = null;
                n.missed = false;
                n.missStartTime = null;
                n.trail = [];
                n.gone = false;
            }
            gameState.playerCursor.trail = [];
            gameState.playerCursor.rotation = 0;
        }

        function startDemoPreview() {
            if (!gameState.audioCtx || !gameState.buffer) return;
            stopCurrentSource();
            const source = gameState.audioCtx.createBufferSource();
            source.buffer = gameState.buffer;
            source.connect(gameState.audioCtx.destination);
            source.start(0, 0);

            gameState.source = source;
            gameState.startTime = gameState.audioCtx.currentTime;
            gameState.mode = "preview";
            gameState.isPaused = false;
            gameState.pausedAt = 0;

            resetScoreState();
            for (const n of gameState.notes) {
                n.hit = false;
                n.hitFly = false;
                n.hitStartTime = null;
                n.missed = false;
                n.missStartTime = null;
                n.trail = [];
                n.gone = false;
            }

            gameState.demoCursor.active = true;
            gameState.demoCursor.x = canvas.width / 2;
            gameState.demoCursor.y = canvas.height / 2;
            gameState.demoCursor.targetX = canvas.width / 2;
            gameState.demoCursor.targetY = canvas.height / 2;
            gameState.demoCursor.rotation = 0;
            gameState.demoCursor.trail = [];
        }

        function judgeHit(absTimeDiff, distRatio) {
            const radiusLimit = 1.05;
            if (distRatio > radiusLimit) return "MISS";

            const tPerfect = 0.025 * JUDGE_WINDOW_SCALE;
            const tGood = 0.060 * JUDGE_WINDOW_SCALE;
            const tBad = 0.120 * JUDGE_WINDOW_SCALE;

            if (absTimeDiff <= tPerfect) return "PERFECT";
            if (absTimeDiff <= tGood) return "GOOD";
            if (absTimeDiff <= tBad) return "BAD";
            return "MISS";
        }

        function markNoteMissed(note, nowAudio) {
            if (!note || note.missed) return;
            note.missed = true;
            note.hit = false;
            note.hitFly = false;
            note.trail = [];
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const dx = note.x - cx;
            const dy = note.y - cy;
            const len = Math.hypot(dx, dy) || 1;
            const speed = 650;
            note.missVX = (dx / len) * speed;
            note.missVY = (dy / len) * speed;
            note.missStartTime = nowAudio;
        }

        function handleTapScreen(clientX, clientY) {
            if (gameState.mode !== "playing" || gameState.isPaused || !gameState.audioCtx) return;
            const now = gameState.audioCtx.currentTime - gameState.startTime;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;

            let bestNote = null;
            let bestScore = Infinity;
            let bestTimeDiff = 0;
            let bestDistRatio = 0;

            const hitSearchWindow = 0.25 * JUDGE_WINDOW_SCALE;

            for (const note of gameState.notes) {
                if (note.hit || note.missed || note.gone) continue;

                const dt = now - note.targetTime;
                const adt = Math.abs(dt);
                if (adt > hitSearchWindow) continue;

                const pos = getNotePosition(note, now);
                const dist = Math.hypot(pos.x - x, pos.y - y);
                const distRatio = dist / note.radius;
                if (distRatio > 1.5) continue;

                const score = adt * 1.0 + distRatio * 0.02;
                if (score < bestScore) {
                    bestScore = score;
                    bestNote = note;
                    bestTimeDiff = dt;
                    bestDistRatio = distRatio;
                }
            }

            if (!bestNote) {
                applyJudgement(null, "MISS", 0, now);
                return;
            }

            const offset = bestTimeDiff;
            const result = judgeHit(Math.abs(offset), bestDistRatio);

            if (result === "MISS") {
                markNoteMissed(bestNote, now);
            } else {
                bestNote.hit = true;
            }

            applyJudgement(bestNote, result, offset, now);
        }

        function handleHit() {
            if (gameState.mode !== "playing" || gameState.isPaused || !gameState.audioCtx) return;
            const now = gameState.audioCtx.currentTime - gameState.startTime;

            let bestNote = null;
            let bestDiff = Infinity;
            let bestDistRatio = 0;

            const hitSearchWindow = 0.25 * JUDGE_WINDOW_SCALE;

            for (const note of gameState.notes) {
                if (note.hit || note.missed || note.gone) continue;
                const diff = now - note.targetTime;
                const ad = Math.abs(diff);
                if (ad > hitSearchWindow) continue;

                const pos = getNotePosition(note, now);
                const dist = Math.hypot(pos.x - note.x, pos.y - note.y);
                const distRatio = dist / note.radius;
                if (distRatio > 1.5) continue;

                if (ad < bestDiff) {
                    bestDiff = ad;
                    bestNote = note;
                    bestDistRatio = distRatio;
                }
            }

            if (!bestNote) {
                applyJudgement(null, "MISS", 0, now);
                return;
            }

            const offset = now - bestNote.targetTime;
            const result = judgeHit(Math.abs(offset), bestDistRatio);

            if (result === "MISS") {
                markNoteMissed(bestNote, now);
            } else {
                bestNote.hit = true;
            }

            applyJudgement(bestNote, result, offset, now);
        }

        function applyJudgement(note, result, offsetSeconds = 0, currentAudioTime = null) {
            let ratio = 0;
            if (result === "PERFECT") ratio = 1.0;
            else if (result === "GOOD") ratio = 0.7;
            else if (result === "BAD") ratio = 0.4;
            else ratio = 0;

            let nowAudio = currentAudioTime;
            if (nowAudio == null && gameState.audioCtx && (gameState.mode === "playing" || gameState.mode === "preview")) {
                nowAudio = gameState.audioCtx.currentTime - gameState.startTime;
            }

            if (note && result !== "MISS") {
                const w = note.weight || 1;
                gameState.scoreValue += ratio * w;
                gameState.hitOffsets.push(offsetSeconds);

                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const dx = note.x - cx;
                const dy = note.y - cy;
                const len = Math.hypot(dx, dy) || 1;
                const speed = 650;

                note.hitFly = true;
                note.hitStartTime = nowAudio != null ? nowAudio : note.targetTime;
                note.hitVX = (dx / len) * speed;
                note.hitVY = (dy / len) * speed;
            }

            if (result === "PERFECT") gameState.perfectCount++;
            else if (result === "GOOD") gameState.goodCount++;
            else if (result === "BAD") gameState.badCount++;
            else gameState.missCount++;

            if (result === "PERFECT" || result === "GOOD") {
                gameState.combo += 1;
                if (gameState.combo > gameState.maxCombo) {
                    gameState.maxCombo = gameState.combo;
                }
            } else {
                gameState.combo = 0;
            }

            registerJudgement(result, note && note.isGold);
            if (note) {
                spawnHitEffect(note.x, note.y, result, note.isGold);
            }
            playHitSound(result, note && note.isGold);

            updateScoreAndUI();
        }

        function registerJudgement(text, isGold = false) {
            gameState.lastJudgement = isGold ? (text + "+") : text;
            gameState.lastJudgementTime = performance.now() / 1000;
        }

        function getClearType() {
            const total = gameState.totalNotes || 0;
            if (!total) return "";
            if (gameState.missCount === 0) {
                if (gameState.goodCount === 0 && gameState.badCount === 0) return "AP";
                return "FC";
            }
            return "";
        }

        function getGradeFromPercent(p) {
            if (p > 100) return { label: "SSS+", level: 9 };
            if (p >= 99.75) return { label: "SSS", level: 8 };
            if (p >= 99.5) return { label: "SS+", level: 7 };
            if (p >= 99) return { label: "SS", level: 6 };
            if (p >= 98) return { label: "S+", level: 5 };
            if (p >= 97) return { label: "S", level: 4 };
            if (p >= 90) return { label: "A", level: 3 };
            if (p >= 80) return { label: "B", level: 2 };
            if (p >= 60) return { label: "C", level: 1 };
            return { label: "D", level: 0 };
        }

        function applyGradeColor(gradeLabel, ...elements) {
            let gradient = false;
            let baseColor = "#e5e7eb";

            if (gradeLabel === "SSS+" || gradeLabel === "SSS") {
                gradient = true;
            } else if (gradeLabel.startsWith("SS") || gradeLabel.startsWith("S")) {
                baseColor = "#fbbf24";
            } else if (gradeLabel === "A") {
                baseColor = "#f97373";
            } else if (gradeLabel === "B") {
                baseColor = "#60a5fa";
            } else if (gradeLabel === "D") {
                baseColor = "#6b7280";
            }

            for (const el of elements) {
                if (!el) continue;
                if (gradient) {
                    el.style.background = "linear-gradient(120deg,#f97316,#ec4899,#6366f1,#22d3ee)";
                    el.style.webkitBackgroundClip = "text";
                    el.style.color = "transparent";
                } else {
                    el.style.background = "";
                    el.style.webkitBackgroundClip = "";
                    el.style.color = baseColor;
                }
            }
        }

        function updateOffsetStats() {
            if (!offsetStatsEl) return;
            const arr = gameState.hitOffsets;
            if (!arr.length) {
                offsetStatsEl.textContent = "";
                return;
            }
            const sum = arr.reduce((a, b) => a + b, 0);
            const avg = sum / arr.length;

            const avgMs = avg * 1000;
            const tendency =
                avgMs > 1 ? "偏晚" : avgMs < -1 ? "偏早" : "基本居中";

            offsetStatsEl.textContent =
                `判定偏差：平均 ${avgMs.toFixed(1)} ms（${tendency}），共命中 ${arr.length} 个 note`;
        }

        function updateScoreAndUI() {
            const totalW = gameState.totalWeight || 1;
            const rawAccuracy = gameState.scoreValue / totalW;
            let basePercent = rawAccuracy * 100;
            if (basePercent < 0) basePercent = 0;

            const total = gameState.totalNotes || 1;
            const comboBonus = (gameState.maxCombo / total) * 2;
            let finalPercent = basePercent + comboBonus;

            gameState.currentScorePercent = finalPercent;
            const gradeInfo = getGradeFromPercent(finalPercent);
            const gradeLabel = gradeInfo.label;
            gameState.currentGrade = gradeLabel;
            gameState.currentGradeLevel = gradeInfo.level;

            const clearType = getClearType();

            scorePercentEl.textContent = finalPercent.toFixed(4) + "%";
            scoreGradeEl.textContent = gradeLabel;
            comboEl.textContent = gameState.combo;
            maxComboEl.textContent = gameState.maxCombo;

            countPerfectEl.textContent = gameState.perfectCount;
            countGoodEl.textContent = gameState.goodCount;
            countBadEl.textContent = gameState.badCount;
            countMissEl.textContent = gameState.missCount;

            centreScoreEl.textContent = finalPercent.toFixed(4) + "% [" + gradeLabel + "]";

            let clearTypeText = clearType || "";
            let comboText = "Combo " + gameState.combo;
            if (clearTypeText) comboText += " · " + clearTypeText;
            centreComboEl.textContent = comboText;

            if (clearType === "AP") {
                centreComboEl.style.color = AP_COLOR;
            } else if (clearType === "FC") {
                centreComboEl.style.color = FC_COLOR;
            } else {
                centreComboEl.style.color = "#f9fafb";
            }

            applyGradeColor(gradeLabel, scoreGradeEl, scorePercentEl, centreScoreEl);

            updateOffsetStats();
        }

        function findNextTargetNote(nowAudio) {
            let bestNote = null;
            let bestScore = Infinity;

            for (const note of gameState.notes) {
                if (note.hit || note.missed || note.gone) continue;
                const dt = note.targetTime - nowAudio;
                if (dt < -0.5 || dt > 3) continue;
                const score = Math.abs(dt);
                if (score < bestScore) {
                    bestScore = score;
                    bestNote = note;
                }
            }
            return bestNote;
        }

        function getNotePosition(note, audioTime) {
            const t = (audioTime - note.spawnTime) / gameState.approachTime;
            const progress = Math.min(Math.max(t, 0), 1.3001);
            return {
                x: note.spawnX + (note.x - note.spawnX) * progress,
                y: note.spawnY + (note.y - note.spawnY) * progress,
                progress
            };
        }

        function playHitSound(result, isGold = false) {
            if (!gameState.audioCtx) return;
            const ctxAudio = gameState.audioCtx;

            const osc = ctxAudio.createOscillator();
            const clickOsc = ctxAudio.createOscillator();
            const gain = ctxAudio.createGain();
            const clickGain = ctxAudio.createGain();

            let freq = 900;
            let baseGain = 0.28;
            let duration = 0.07;

            if (result === "PERFECT") {
                freq = isGold ? 1400 : 1200;
                baseGain = 0.32;
                duration = 0.06;
            } else if (result === "GOOD") {
                freq = isGold ? 1150 : 1000;
                baseGain = 0.30;
                duration = 0.07;
            } else if (result === "BAD") {
                freq = 650;
                baseGain = 0.34;
                duration = 0.09;
            } else {
                freq = 420;
                baseGain = 0.26;
                duration = 0.06;
            }

            const gradeLevel = gameState.currentGradeLevel || 0;
            const volumeFactor = Math.max(0.55, 1 - gradeLevel * 0.04);
            baseGain *= volumeFactor * (isGold ? 1.15 : 1.0);

            osc.frequency.value = freq;
            osc.type = "square";

            clickOsc.frequency.value = 2600;
            clickOsc.type = "triangle";

            const now = ctxAudio.currentTime;

            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(baseGain, now + 0.004);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

            clickGain.gain.setValueAtTime(baseGain * 0.75, now);
            clickGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.55);

            osc.connect(gain);
            clickOsc.connect(clickGain);
            gain.connect(ctxAudio.destination);
            clickGain.connect(ctxAudio.destination);

            osc.start(now);
            clickOsc.start(now);
            osc.stop(now + duration + 0.02);
            clickOsc.stop(now + duration + 0.05);
        }

        function spawnHitEffect(x, y, type, isGold = false) {
            const now = performance.now() / 1000;

            let baseColor = "255,255,255";
            if (type === "GOOD") baseColor = "190, 242, 100";
            else if (type === "BAD") baseColor = "251, 191, 36";
            else if (type === "MISS") baseColor = "248, 113, 113";

            if (isGold) {
                baseColor = "252, 211, 77";
            }

            const gradeScale = 1 + (gameState.currentGradeLevel || 0) * 0.08;
            let baseScale = 1;
            let duration = 0.42;
            let rings = 2;
            let particles = 16;

            if (type === "PERFECT") {
                baseScale = 1.35;
                duration = 0.5;
                rings = isGold ? 4 : 3;
                particles = isGold ? 28 : 22;
            } else if (type === "GOOD") {
                baseScale = 1.05;
                duration = 0.4;
            } else if (type === "BAD") {
                baseScale = 0.9;
                duration = 0.35;
                particles = 10;
            } else {
                baseScale = 0.8;
                duration = 0.3;
                particles = 8;
            }

            if (isGold) {
                baseScale *= 1.15;
            }

            const scale = baseScale * gradeScale;

            const particleList = [];
            for (let i = 0; i < particles; i++) {
                particleList.push({
                    angle: (i / particles) * Math.PI * 2 + Math.random() * 0.3,
                    speed: 90 + Math.random() * 130,
                    radius: 4 + Math.random() * 4,
                });
            }

            gameState.hitEffects.push({
                x,
                y,
                startTime: now,
                duration,
                color: baseColor,
                scale,
                rings,
                particles: particleList,
                isGold
            });
        }

        function drawHitEffects(now) {
            ctx.save();
            for (let i = gameState.hitEffects.length - 1; i >= 0; i--) {
                const e = gameState.hitEffects[i];
                const t = (now - e.startTime) / e.duration;
                if (t >= 1) {
                    gameState.hitEffects.splice(i, 1);
                    continue;
                }

                const alpha = 1 - t;

                for (let rIndex = 0; rIndex < e.rings; rIndex++) {
                    const ringT = t * (0.7 + rIndex * 0.2);
                    const radius = (16 + ringT * 100) * e.scale;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(${e.color}, ${alpha * (0.6 - rIndex * 0.15)})`;
                    ctx.lineWidth = 3 * (1 - ringT);
                    ctx.stroke();
                }

                for (const p of e.particles) {
                    const dist = p.speed * t * e.scale;
                    const px = e.x + Math.cos(p.angle) * dist;
                    const py = e.y + Math.sin(p.angle) * dist;
                    ctx.beginPath();
                    ctx.arc(px, py, p.radius * (1 - t), 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${e.color}, ${alpha})`;
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        function drawJudgement(now) {
            if (!gameState.lastJudgement) {
                judgementTextEl.textContent = "";
                judgementTextEl.style.transform = "scale(1)";
                return;
            }
            const elapsed = now - gameState.lastJudgementTime;
            const duration = 0.9;
            if (elapsed > duration) {
                gameState.lastJudgement = "";
                judgementTextEl.textContent = "";
                judgementTextEl.style.transform = "scale(1)";
                return;
            }

            const t = elapsed / duration;
            const scale = 1 + 0.7 * (1 - t);
            const opacity = 1 - t;

            judgementTextEl.textContent = gameState.lastJudgement;
            judgementTextEl.style.transform = `scale(${scale})`;
            const txt = gameState.lastJudgement;
            const isGold = txt.endsWith("+");
            const base = isGold ? "252, 211, 77" : (
                txt.startsWith("PERFECT") ? "248,250,252" :
                    txt.startsWith("GOOD") ? "190,242,100" :
                        txt.startsWith("BAD") ? "251,191,36" :
                            "248,113,113"
            );
            judgementTextEl.style.color = `rgba(${base}, ${opacity})`;
        }

        function drawChainLine(note, targetNote, nowAudio) {
            const prev = note.prevOutline;
            if (!prev) return;

            const appear1 = prev.spawnTime;
            const disappear1 = prev.targetTime + OUTLINE_HIDE_AFTER;
            const appear2 = note.spawnTime;
            const disappear2 = note.targetTime + OUTLINE_HIDE_AFTER;

            const appear = Math.max(appear1, appear2);
            const disappear = Math.min(disappear1, disappear2);

            if (nowAudio < appear || nowAudio > disappear) return;

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(prev.x, prev.y);
            ctx.lineTo(note.x, note.y);

            const isCurrentPath = (note === targetNote || prev === targetNote);
            ctx.strokeStyle = isCurrentPath
                ? "rgba(236,252,203,0.8)"
                : "rgba(148,163,184,0.3)";
            ctx.lineWidth = isCurrentPath ? 3 : 2;
            ctx.setLineDash(isCurrentPath ? [10, 6] : [3, 10]);
            ctx.stroke();
            ctx.restore();
        }

        function drawOutlineAndJudgeRing(note, audioTime, targetNote) {
            if (note.hit || note.missed || note.gone) return;

            const appearTime = note.spawnTime;
            const disappearTime = note.targetTime + OUTLINE_HIDE_AFTER;

            if (audioTime < appearTime || audioTime > disappearTime) {
                return;
            }

            const isTarget = (note === targetNote);

            ctx.save();

            ctx.lineWidth = isTarget ? 5 : 3;
            const baseAlpha = isTarget ? 0.95 : 0.55;

            if (note.isGold) {
                ctx.strokeStyle = isTarget
                    ? `rgba(252, 211, 77, ${baseAlpha})`
                    : `rgba(252, 211, 77, 0.7)`;
            } else {
                ctx.strokeStyle = isTarget
                    ? "rgba(244,244,255,0.95)"
                    : `rgba(148,163,255,${baseAlpha})`;
            }

            const sides = 4 + ((note.x + note.y) | 0) % 3;
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                const r = note.radius * (isTarget ? 1.25 : 1.1);
                const px = note.x + Math.cos(angle) * r;
                const py = note.y + Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.stroke();

            const dt = note.targetTime - audioTime;
            const remaining = Math.min(Math.max(dt, 0), OUTLINE_SHOW_BEFORE);
            const k = OUTLINE_SHOW_BEFORE > 0 ? remaining / OUTLINE_SHOW_BEFORE : 0;
            const scale = 1 + 1.4 * k;
            const ringRadius = note.radius * scale * 1.1;
            const ringAlpha = (isTarget ? 0.4 : 0.2) + (1 - k) * (isTarget ? 0.6 : 0.5);

            ctx.beginPath();
            ctx.arc(note.x, note.y, ringRadius, 0, Math.PI * 2);
            if (note.isGold) {
                ctx.strokeStyle = isTarget
                    ? `rgba(253, 224, 71,${ringAlpha})`
                    : `rgba(250, 204, 21,${ringAlpha * 0.9})`;
            } else {
                ctx.strokeStyle = isTarget
                    ? `rgba(244,244,255,${ringAlpha})`
                    : `rgba(248,250,252,${ringAlpha})`;
            }
            ctx.lineWidth = isTarget ? 3 : 2;
            ctx.setLineDash(isTarget ? [2, 8] : [6, 10]);
            ctx.stroke();

            ctx.restore();
        }

        function drawNote(note, audioTime, deltaTime, targetNote) {
            // 命中后：多边形飞出并淡出
            if (note.hit && note.hitFly && !note.gone) {
                const start = typeof note.hitStartTime === "number" ? note.hitStartTime : audioTime;
                const t = audioTime - start;
                const life = 0.55;
                const x = note.x + (note.hitVX || 0) * t;
                const y = note.y + (note.hitVY || 0) * t;

                const margin = 60;
                if (x < -margin || x > canvas.width + margin || y < -margin || y > canvas.height + margin) {
                    note.gone = true;
                    return;
                }

                const alpha = Math.max(0, 1 - t / life);
                if (alpha <= 0) {
                    note.gone = true;
                    return;
                }

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(x, y);
                note.rotation += note.rotationSpeed * deltaTime * 1.5;
                ctx.rotate(note.rotation || 0);

                const r = note.radius * 0.9;

                const gradient = ctx.createRadialGradient(0, 0, r * 0.1, 0, 0, r);
                if (note.isGold) {
                    gradient.addColorStop(0, "rgba(255, 252, 200,1)");
                    gradient.addColorStop(0.5, "rgba(250, 204, 21,0.9)");
                    gradient.addColorStop(1, "rgba(217, 119, 6,0.9)");
                } else {
                    gradient.addColorStop(0, "rgba(248,250,252,1)");
                    gradient.addColorStop(0.4, "rgba(191,219,254,1)");
                    gradient.addColorStop(1, "rgba(129,140,248,1)");
                }

                ctx.beginPath();
                const sides = 4 + ((note.x + note.y) | 0) % 3;
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2;
                    const rr = r * (0.85 + (i % 2) * 0.15);
                    const px = Math.cos(angle) * rr;
                    const py = Math.sin(angle) * rr;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.lineWidth = 3.5;
                ctx.strokeStyle = "rgba(15,23,42,0.98)";
                ctx.stroke();
                ctx.restore();
                return;
            }

            // MISS 音符：飞出后立即移除
            if (note.missed && !note.gone) {
                const start = typeof note.missStartTime === "number" ? note.missStartTime : audioTime;
                const t = audioTime - start;
                const life = 0.7;
                const x = note.x + (note.missVX || 0) * t;
                const y = note.y + (note.missVY || 0) * t;

                const margin = 60;
                if (x < -margin || x > canvas.width + margin || y < -margin || y > canvas.height + margin) {
                    note.gone = true;
                    return;
                }

                const alpha = Math.max(0, 1 - t / life);
                if (alpha <= 0) {
                    note.gone = true;
                    return;
                }

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(x, y, note.radius * 0.7, 0, Math.PI * 2);
                ctx.strokeStyle = "rgba(248,113,113,1)";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
                return;
            }

            if (note.gone) return;

            const pos = getNotePosition(note, audioTime);
            if (pos.progress <= 0) return;
            if (pos.progress >= 1.3) {
                if (!note.hit && !note.missed && !note.gone) {
                    markNoteMissed(note, audioTime);
                    applyJudgement(note, "MISS", 0, audioTime);
                }
                return;
            }

            const isTarget = (note === targetNote);

            note.trail.push({ x: pos.x, y: pos.y });
            if (note.trail.length > 18) note.trail.shift();

            ctx.save();
            ctx.lineJoin = "round";
            ctx.lineCap = "round";

            for (let i = 0; i < note.trail.length; i++) {
                const p = note.trail[i];
                const alpha = (i + 1) / note.trail.length;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3 + 2 * (i / note.trail.length), 0, Math.PI * 2);
                const base = note.isGold
                    ? `rgba(252,211,77,${alpha * 0.45})`
                    : isTarget
                        ? `rgba(248,250,252,${alpha * 0.45})`
                        : `rgba(96,165,250,${alpha * 0.35})`;
                ctx.fillStyle = base;
                ctx.fill();
            }

            const p = Math.min(Math.max(pos.progress, 0), 1);
            let sizeScale = 0.9 + 0.3 * Math.sin(p * Math.PI * 0.5);
            if (isTarget) sizeScale *= 1.1;
            const drawRadius = note.radius * sizeScale;

            note.rotation += note.rotationSpeed * deltaTime;

            ctx.translate(pos.x, pos.y);
            ctx.rotate(note.rotation);

            const sides = 4 + ((note.x + note.y) | 0) % 3;
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                const r = drawRadius * (0.85 + (i % 2) * 0.15);
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();

            const gradient = ctx.createRadialGradient(0, 0, drawRadius * 0.15, 0, 0, drawRadius);
            if (note.isGold) {
                gradient.addColorStop(0, "rgba(255,252,204,1)");
                gradient.addColorStop(0.4, "rgba(252,211,77,1)");
                gradient.addColorStop(1, "rgba(217,119,6,1)");
            } else if (isTarget) {
                gradient.addColorStop(0, "rgba(248,250,252,1)");
                gradient.addColorStop(0.4, "rgba(191,219,254,1)");
                gradient.addColorStop(1, "rgba(129,140,248,1)");
            } else {
                gradient.addColorStop(0, "rgba(248,250,252,1)");
                gradient.addColorStop(0.4, "rgba(129,140,248,1)");
                gradient.addColorStop(1, "rgba(236,72,153,1)");
            }

            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.lineWidth = isTarget ? 4 : 3;
            ctx.strokeStyle = "rgba(15,23,42,0.98)";
            ctx.stroke();

            ctx.restore();
        }

        function updateAutoPlay(nowAudio, deltaTime) {
            if (gameState.mode !== "preview" || !gameState.buffer) return;

            const hitWindow = 0.03 * JUDGE_WINDOW_SCALE;

            for (const note of gameState.notes) {
                if (note.hit || note.missed || note.gone) continue;
                const diff = nowAudio - note.targetTime;
                if (Math.abs(diff) <= hitWindow) {
                    note.hit = true;
                    gameState.demoCursor.targetX = note.x;
                    gameState.demoCursor.targetY = note.y;
                    applyJudgement(note, "PERFECT", diff, nowAudio);
                    break;
                }
            }

            const nextNote = findNextTargetNote(nowAudio);
            if (nextNote) {
                gameState.demoCursor.targetX = nextNote.x;
                gameState.demoCursor.targetY = nextNote.y;
            }

            const cursor = gameState.demoCursor;
            if (!cursor || !cursor.active) return;
            const dx = cursor.targetX - cursor.x;
            const dy = cursor.targetY - cursor.y;
            const dist = Math.hypot(dx, dy);
            const speed = 900;
            if (dist > 0.5) {
                const move = Math.min(dist, speed * deltaTime);
                cursor.x += dx / dist * move;
                cursor.y += dy / dist * move;
            }
            cursor.rotation += deltaTime * 4;
            cursor.trail.push({ x: cursor.x, y: cursor.y });
            if (cursor.trail.length > 24) cursor.trail.shift();
        }

        function drawCursor(cursor, mainColor, trailColor) {
            if (!cursor || !cursor.active) return;

            ctx.save();
            const trail = cursor.trail || [];
            for (let i = 0; i < trail.length; i++) {
                const p = trail[i];
                const alpha = (i + 1) / trail.length;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4 * alpha, 0, Math.PI * 2);
                ctx.fillStyle = `${trailColor}${alpha * 0.6})`;
                ctx.fill();
            }

            ctx.translate(cursor.x, cursor.y);
            ctx.rotate(cursor.rotation || 0);

            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.lineTo(9, 5);
            ctx.lineTo(-9, 5);
            ctx.closePath();
            ctx.fillStyle = mainColor;
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "rgba(15,23,42,0.95)";
            ctx.stroke();

            ctx.restore();
        }

        function drawAutoCursor() {
            const cursor = gameState.demoCursor;
            drawCursor(cursor, "rgba(56,189,248,0.98)", "rgba(56,189,248,");
        }

        function drawPlayerCursor() {
            const cursor = gameState.playerCursor;
            cursor.rotation += 0.1;
            drawCursor(cursor, "rgba(236,72,153,0.98)", "rgba(244,114,182,");
        }

        function exportScoreImage() {
            const total = gameState.totalNotes || 1;
            if (!total) return;

            const songName = gameState.currentSongName || "Unknown Track";

            const canvasOut = document.createElement("canvas");
            canvasOut.width = 900;
            canvasOut.height = 500;
            const c = canvasOut.getContext("2d");

            const grad = c.createLinearGradient(0, 0, 900, 500);
            grad.addColorStop(0, "#020617");
            grad.addColorStop(0.35, "#1d2338");
            grad.addColorStop(1, "#4f46e5");
            c.fillStyle = grad;
            c.fillRect(0, 0, 900, 500);

            const cx = 900 / 2;
            const cy = 500 / 2;
            const halo = c.createRadialGradient(cx, cy, 0, cx, cy, 260);
            halo.addColorStop(0, "rgba(248,250,252,0.18)");
            halo.addColorStop(0.4, "rgba(56,189,248,0.06)");
            halo.addColorStop(1, "rgba(15,23,42,0)");
            c.fillStyle = halo;
            c.beginPath();
            c.arc(cx, cy, 260, 0, Math.PI * 2);
            c.fill();

            c.fillStyle = "#e5e7eb";
            c.font = "20px system-ui";
            c.fillText("CelestialDX - 成绩单", 40, 50);

            c.font = "24px system-ui";
            c.fillStyle = "#fbbf24";
            c.fillText("乐曲：" + songName, 40, 85);

            const diffConf = DIFFICULTY_CONFIG[gameState.difficulty] || DIFFICULTY_CONFIG.classic;
            c.font = "16px system-ui";
            c.fillStyle = "#cbd5f5";
            c.fillText("难度：" + diffConf.label, 40, 110);

            const gradeInfo = getGradeFromPercent(gameState.currentScorePercent);
            const gradeLabel = gradeInfo.label;
            const clearType = getClearType();

            let gradeFillStyle;
            let scoreColor = "#e5e7eb";
            if (gradeLabel === "SSS+" || gradeLabel === "SSS") {
                const g = c.createLinearGradient(40, 140, 400, 180);
                g.addColorStop(0, "#f97316");
                g.addColorStop(0.5, "#ec4899");
                g.addColorStop(1, "#22d3ee");
                gradeFillStyle = g;
                scoreColor = "#fee2e2";
            } else if (gradeLabel.startsWith("SS") || gradeLabel.startsWith("S")) {
                gradeFillStyle = "#fbbf24";
                scoreColor = "#facc15";
            } else if (gradeLabel === "A") {
                gradeFillStyle = "#f97373";
                scoreColor = "#fecaca";
            } else if (gradeLabel === "B") {
                gradeFillStyle = "#60a5fa";
                scoreColor = "#bfdbfe";
            } else if (gradeLabel === "D") {
                gradeFillStyle = "#6b7280";
                scoreColor = "#9ca3af";
            } else {
                gradeFillStyle = "#e5e7eb";
                scoreColor = "#e5e7eb";
            }

            c.font = "78px system-ui";
            c.fillStyle = gradeFillStyle;
            c.fillText(gradeLabel, 40, 180);

            if (clearType) {
                c.font = "30px system-ui";
                c.fillStyle = clearType === "AP" ? AP_COLOR : FC_COLOR;
                c.fillText(clearType, 40, 215);
            }

            c.font = "40px system-ui";
            c.fillStyle = scoreColor;
            c.fillText(gameState.currentScorePercent.toFixed(4) + "%", 40, 260);

            c.font = "22px system-ui";
            c.fillStyle = "#e5e7eb";
            const lineY = 300;
            c.fillText(`Max Combo: ${gameState.maxCombo}`, 40, lineY);
            c.fillText(`PERFECT: ${gameState.perfectCount}`, 40, lineY + 32);
            c.fillText(`GOOD: ${gameState.goodCount}`, 40, lineY + 64);
            c.fillText(`BAD: ${gameState.badCount}`, 320, lineY + 32);
            c.fillText(`MISS: ${gameState.missCount}`, 320, lineY + 64);
            c.fillText(`Notes: ${gameState.totalNotes}`, 320, lineY);

            if (gameState.notes.length && gameState.actualNpm) {
                c.fillText(`NPM: ${gameState.actualNpm.toFixed(1)}`, 320, lineY + 96);
            }

            if (gameState.hitOffsets && gameState.hitOffsets.length) {
                const arr = gameState.hitOffsets;
                const avg = arr.reduce((a, b) => a + b, 0) / arr.length;
                const avgMs = avg * 1000;
                const text = `平均偏差: ${avgMs.toFixed(1)} ms`;
                c.fillText(text, 40, 380);
            }

            c.font = "16px system-ui";
            c.fillStyle = "rgba(226, 232, 240, 0.75)";
            c.fillText("Generated by CelestialDX – share this with your friends!", 40, 430);

            const url = canvasOut.toDataURL("image/png");
            const a = document.createElement("a");
            const safeName = songName.replace(/[^a-zA-Z0-9\u4e00-\u9fa5_-]/g, "_");
            a.href = url;
            a.download = `score_${safeName || "track"}.png`;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        exportScoreBtn.addEventListener("click", exportScoreImage);

        function loop() {
            requestAnimationFrame(loop);
            const nowPerf = performance.now();
            const deltaTime = (loop.lastTime != null ? (nowPerf - loop.lastTime) : 16) / 1000;
            loop.lastTime = nowPerf;

            let nowAudio = 0;
            if ((gameState.mode === "playing" || gameState.mode === "preview") && gameState.audioCtx && gameState.buffer) {
                if (gameState.mode === "playing" && gameState.isPaused) {
                    nowAudio = gameState.pausedAt || 0;
                } else {
                    nowAudio = gameState.audioCtx.currentTime - gameState.startTime;
                }
            }

            const targetNote = findNextTargetNote(nowAudio);

            drawBackground(deltaTime);

            for (const note of gameState.notes) {
                drawChainLine(note, targetNote, nowAudio);
            }

            for (const note of gameState.notes) {
                drawOutlineAndJudgeRing(note, nowAudio, targetNote);
            }

            for (const note of gameState.notes) {
                drawNote(note, nowAudio, deltaTime, targetNote);
            }

            gameState.notes = gameState.notes.filter(n => {
                if (n.gone) return false;
                if (!n.missed && !(n.hit && n.hitFly)) return true;
                const tStart = n.missed
                    ? (typeof n.missStartTime === "number" ? n.missStartTime : n.targetTime)
                    : (typeof n.hitStartTime === "number" ? n.hitStartTime : n.targetTime);
                const life = n.missed ? 0.7 : 0.55;
                return nowAudio - tStart < life;
            });

            if (gameState.mode === "preview") {
                updateAutoPlay(nowAudio, deltaTime);
                drawAutoCursor();
            }
            if (gameState.mode === "playing") {
                drawPlayerCursor();
            }

            const nowSeconds = nowPerf / 1000;
            drawHitEffects(nowSeconds);
            drawJudgement(nowSeconds);

            if (progressBarFill && gameState.buffer) {
                const r = Math.min(Math.max(nowAudio / gameState.buffer.duration, 0), 1);
                progressBarFill.style.transform = `scaleX(${r})`;
            } else if (progressBarFill) {
                progressBarFill.style.transform = "scaleX(0)";
            }

            if (
                gameState.mode === "playing" &&
                gameState.buffer &&
                !gameState.isPaused &&
                nowAudio > gameState.buffer.duration + 0.3
            ) {
                gameState.mode = "result";
                stopCurrentSource();
                showResultScreen();
                exportScoreBtn.disabled = false;
            } else if (
                gameState.mode === "preview" &&
                gameState.buffer &&
                nowAudio > gameState.buffer.duration + 0.1
            ) {
                startDemoPreview();
            }
        }
        loop.lastTime = null;
        loop();
    </script>
</body>

</html>
