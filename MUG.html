<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <title>图形节奏音乐游戏 – 多难度&金色音符</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding: 16px;
            overflow: hidden;
            background: radial-gradient(circle at top, #1b1f3a, #050710);
            color: #f5f5f5;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 8px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .panel {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .panel label {
            font-size: 14px;
            opacity: 0.8;
        }

        input[type="file"] {
            font-size: 13px;
            max-width: 240px;
        }

        button,
        select {
            border: none;
            padding: 8px 14px;
            border-radius: 999px;
            font-size: 13px;
            cursor: pointer;
            background: linear-gradient(135deg, #4f46e5, #ec4899);
            color: white;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
            transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease, background 0.2s ease;
            outline: none;
        }

        select {
            padding-right: 24px;
            background: linear-gradient(135deg, #0f172a, #4f46e5);
        }

        button:disabled,
        select:disabled {
            opacity: 0.4;
            cursor: default;
            box-shadow: none;
            filter: grayscale(0.3);
        }

        button:not(:disabled):hover,
        select:not(:disabled):hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.45);
            filter: brightness(1.05);
        }

        .info {
            font-size: 13px;
            opacity: 0.75;
            margin-bottom: 8px;
            text-align: center;
        }

        .stats {
            display: flex;
            gap: 14px;
            font-size: 13px;
            margin-bottom: 4px;
            align-items: baseline;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stats span.label {
            opacity: 0.7;
            margin-right: 4px;
        }

        .stats .value {
            font-weight: 600;
        }

        .judge-stats {
            display: flex;
            gap: 12px;
            font-size: 12px;
            margin-bottom: 6px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .judge-stats span {
            opacity: 0.85;
        }

        .judge-stats .perfect {
            color: #fef9c3;
        }

        .judge-stats .good {
            color: #bbf7d0;
        }

        .judge-stats .bad {
            color: #fed7aa;
        }

        .judge-stats .miss {
            color: #fecaca;
        }

        .hint {
            margin-top: 2px;
            font-size: 12px;
            opacity: 0.6;
            text-align: center;
            margin-bottom: 6px;
        }

        #offsetStats {
            font-size: 12px;
            opacity: 0.75;
            margin-bottom: 8px;
            text-align: center;
        }

        .game-wrapper {
            position: relative;
            display: inline-block;
        }

        canvas {
            border-radius: 20px;
            box-shadow: 0 20px 70px rgba(0, 0, 0, 0.7);
            background: radial-gradient(circle at bottom, #020617, #030712 55%, #020617 100%);
            max-width: 100%;
            display: block;
        }

        .center-hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            text-shadow: 0 0 16px rgba(0, 0, 0, 0.9);
        }

        /* 中心无边框，只保留炫光文字 */
        .center-score {
            font-size: 26px;
            margin-bottom: 6px;
            letter-spacing: 2px;
            z-index: 1;
            color: #e5e7eb;
            text-shadow:
                0 0 18px rgba(59, 130, 246, 0.8),
                0 0 30px rgba(236, 72, 153, 0.6);
        }

        .center-combo {
            font-size: 18px;
            margin-bottom: 6px;
            opacity: 0.95;
            z-index: 1;
            color: #f9fafb;
            text-shadow:
                0 0 15px rgba(56, 189, 248, 0.8),
                0 0 26px rgba(37, 99, 235, 0.7);
        }

        .center-judge {
            min-height: 28px;
            font-size: 26px;
            font-weight: 800;
            letter-spacing: 6px;
            text-transform: uppercase;
            z-index: 1;
            transition: transform 0.1s ease;
        }

        /* 全屏模式 */
        .fullscreen-play {
            position: fixed !important;
            inset: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999;
            background: #000;
            margin: 0 !important;
            padding: 0 !important;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fullscreen-play canvas {
            width: 100vw !important;
            height: 100vh !important;
            object-fit: contain;
        }
    </style>
</head>

<body>
    <h1>图形节奏音乐游戏</h1>

    <div class="panel">
        <label>
            选择 MP3：
            <input type="file" id="fileInput" accept="audio/mpeg,audio/mp3" />
        </label>
        <button id="startBtn" disabled>开始游戏</button>
        <select id="difficultySelect">
            <option value="easy">简单</option>
            <option value="normal" selected>普通</option>
            <option value="hard">困难</option>
            <option value="master">大师</option>
        </select>
        <button id="useExampleBtn">示例歌曲</button>
        <button id="exportChartBtn" disabled>导出谱面</button>
        <button id="exportScoreBtn" disabled>导出成绩图</button>
    </div>

    <div class="info" id="infoText">
        请选择一首 mp3，程序会用频域分析 + pattern 自动生成节奏谱面。<br />
        游戏中：图形对齐轮廓 + 判定环收缩到目标时按下 <b>空格</b> 或点击 / 触摸。
    </div>

    <div class="stats">
        <div>
            <span class="label">Score</span>
            <span class="value" id="scorePercent">0.0000%</span>
        </div>
        <div>
            <span class="label">Grade</span>
            <span class="value" id="scoreGrade">D</span>
        </div>
        <div>
            <span class="label">Combo</span>
            <span class="value" id="combo">0</span>
        </div>
        <div>
            <span class="label">Max Combo</span>
            <span class="value" id="maxCombo">0</span>
        </div>
        <div>
            <span class="label">Notes</span>
            <span class="value" id="noteCount">0</span>
        </div>
    </div>

    <div class="judge-stats">
        <span class="perfect">PERFECT: <span id="countPerfect">0</span></span>
        <span class="good">GOOD: <span id="countGood">0</span></span>
        <span class="bad">BAD: <span id="countBad">0</span></span>
        <span class="miss">MISS: <span id="countMiss">0</span></span>
    </div>

    <div class="hint">
        分数以 100.0000% 为基准，每个 note 按权重平分：<br />
        PERFECT = 1.0，GOOD = 0.7，BAD = 0.4，MISS = 0；金色音符权重 ×3。<br />
        额外根据最大连击加最多 +2% 加成，可突破 100% 拿到 SSS+。
    </div>

    <div class="info" id="offsetStats"></div>

    <div id="gameContainer" class="game-wrapper">
        <canvas id="gameCanvas" width="900" height="540"></canvas>
        <div class="center-hud">
            <div id="centerScore" class="center-score">0.0000% [D]</div>
            <div id="centerCombo" class="center-combo">Combo 0</div>
            <div id="judgementText" class="center-judge"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        const fileInput = document.getElementById("fileInput");
        const startBtn = document.getElementById("startBtn");
        const infoText = document.getElementById("infoText");
        const difficultySelect = document.getElementById("difficultySelect");
        const useExampleBtn = document.getElementById("useExampleBtn");
        const exportChartBtn = document.getElementById("exportChartBtn");
        const exportScoreBtn = document.getElementById("exportScoreBtn");
        const offsetStatsEl = document.getElementById("offsetStats");

        const scorePercentEl = document.getElementById("scorePercent");
        const scoreGradeEl = document.getElementById("scoreGrade");
        const comboEl = document.getElementById("combo");
        const maxComboEl = document.getElementById("maxCombo");
        const noteCountEl = document.getElementById("noteCount");

        const countPerfectEl = document.getElementById("countPerfect");
        const countGoodEl = document.getElementById("countGood");
        const countBadEl = document.getElementById("countBad");
        const countMissEl = document.getElementById("countMiss");

        const centreScoreEl = document.getElementById("centerScore");
        const centreComboEl = document.getElementById("centerCombo");
        const judgementTextEl = document.getElementById("judgementText");

        const OUTLINE_SHOW_BEFORE = 0.5;
        const OUTLINE_HIDE_AFTER = 0.25;
        const EXAMPLE_MP3_URL = "example.mp3"; // 请把 example.mp3 放在同目录

        const gameState = {
            audioCtx: null,
            buffer: null,
            source: null,
            isPlaying: false,
            startTime: 0,
            approachTime: 1.4,
            notes: [],
            totalNotes: 0,
            totalWeight: 1,
            scoreValue: 0,
            combo: 0,
            maxCombo: 0,
            perfectCount: 0,
            goodCount: 0,
            badCount: 0,
            missCount: 0,
            currentScorePercent: 0,
            currentGrade: "D",
            currentGradeLevel: 0,
            lastJudgement: "",
            lastJudgementTime: 0,
            hitEffects: [],
            bgCircles: [],
            lastBeats: [],
            lastBeatPeriod: 0.5,
            hitOffsets: []
        };

        exportChartBtn.disabled = true;
        exportScoreBtn.disabled = true;

        function getDifficulty() {
            return difficultySelect ? difficultySelect.value : "normal";
        }

        // Pointer / Touch
        canvas.addEventListener("pointerdown", (e) => {
            e.preventDefault();
            if (gameState.audioCtx && gameState.audioCtx.state === "suspended") {
                gameState.audioCtx.resume();
            }
            handleTapScreen(e.clientX, e.clientY);
        });

        canvas.addEventListener("touchstart", (e) => {
            e.preventDefault();
            if (gameState.audioCtx && gameState.audioCtx.state === "suspended") {
                gameState.audioCtx.resume();
            }
            const touch = e.changedTouches[0];
            if (!touch) return;
            handleTapScreen(touch.clientX, touch.clientY);
        }, { passive: false });

        // 全屏
        function enterFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                return elem.requestFullscreen().catch(() => { });
            } else if (elem.webkitRequestFullscreen) {
                return elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) {
                return elem.msRequestFullscreen();
            }
        }

        function exitFullscreen() {
            const doc = document;
            if (
                doc.fullscreenElement ||
                doc.webkitFullscreenElement ||
                doc.msFullscreenElement
            ) {
                if (doc.exitFullscreen) {
                    doc.exitFullscreen();
                } else if (doc.webkitExitFullscreen) {
                    doc.webkitExitFullscreen();
                } else if (doc.msExitFullscreen) {
                    doc.msExitFullscreen();
                }
            }
        }

        function resizeCanvas() {
            const scale = Math.min(window.innerWidth / 1000, window.innerHeight / 650, 1);
            canvas.style.transformOrigin = "top center";
            canvas.style.transform = `scale(${scale})`;
        }
        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();

        function initBackground() {
            gameState.bgCircles = [];
            for (let i = 0; i < 20; i++) {
                gameState.bgCircles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    r: 20 + Math.random() * 60,
                    speed: 0.2 + Math.random() * 0.4,
                    alpha: 0.06 + Math.random() * 0.1
                });
            }
        }
        initBackground();

        // 难度设置：更明显的飞行速度差别
        function applyDifficultySettings() {
            const diff = getDifficulty();
            if (diff === "easy") {
                gameState.approachTime = 2.0;    // 很慢
            } else if (diff === "normal") {
                gameState.approachTime = 1.4;
            } else if (diff === "hard") {
                gameState.approachTime = 0.9;
            } else if (diff === "master") {
                gameState.approachTime = 0.7;    // 非常快
            }
        }

        if (difficultySelect) {
            difficultySelect.addEventListener("change", () => {
                applyDifficultySettings();
                if (gameState.lastBeats && gameState.lastBeats.length) {
                    prepareNotes(gameState.lastBeats, gameState.lastBeatPeriod || 0.5);
                    gameState.totalNotes = gameState.notes.length;
                    noteCountEl.textContent = gameState.totalNotes;
                    resetScoreState();
                }
            });
        }

        // 音频加载：文件
        fileInput.addEventListener("change", async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            startBtn.disabled = true;
            exportChartBtn.disabled = true;
            exportScoreBtn.disabled = true;
            judgementTextEl.textContent = "";
            infoText.textContent = "正在解码音频并进行频域分析，请稍等几秒...";

            try {
                const arrayBuffer = await file.arrayBuffer();
                if (!gameState.audioCtx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    gameState.audioCtx = new AC();
                }
                const audioCtx = gameState.audioCtx;
                gameState.buffer = await audioCtx.decodeAudioData(arrayBuffer);

                infoText.textContent = "基于多频段谱通量 + BPM + pattern 生成谱面中...";
                const { beats, beatPeriod } = generateBeatTimes(gameState.buffer);

                gameState.lastBeats = beats;
                gameState.lastBeatPeriod = beatPeriod || 0.5;

                if (beats.length === 0) {
                    infoText.textContent = "节拍检测结果为空，可能是比较平的背景音。你仍可点“开始游戏”体验一下。";
                } else {
                    infoText.textContent = `已生成节奏谱面，原始约 ${beats.length} 个音符（不同难度会调整数量和密度）。`;
                }

                applyDifficultySettings();
                prepareNotes(beats, beatPeriod);
                gameState.totalNotes = gameState.notes.length;
                noteCountEl.textContent = gameState.totalNotes;
                startBtn.disabled = false;
                exportChartBtn.disabled = false;
                exportScoreBtn.disabled = true;
                resetScoreState();
            } catch (err) {
                console.error(err);
                infoText.textContent = "音频解码失败，请尝试换一首 mp3。";
            }
        });

        // 音频加载：示例
        useExampleBtn.addEventListener("click", async () => {
            try {
                startBtn.disabled = true;
                exportChartBtn.disabled = true;
                exportScoreBtn.disabled = true;
                infoText.textContent = "正在加载示例 mp3...";

                if (!gameState.audioCtx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    gameState.audioCtx = new AC();
                }
                const res = await fetch(EXAMPLE_MP3_URL);
                const arrayBuffer = await res.arrayBuffer();
                const buffer = await gameState.audioCtx.decodeAudioData(arrayBuffer);
                gameState.buffer = buffer;

                infoText.textContent = "基于示例歌曲生成谱面中...";
                const { beats, beatPeriod } = generateBeatTimes(buffer);

                gameState.lastBeats = beats;
                gameState.lastBeatPeriod = beatPeriod || 0.5;

                if (beats.length === 0) {
                    infoText.textContent = "节拍检测结果为空，可能是比较平的背景音。你仍可点“开始游戏”体验一下。";
                } else {
                    infoText.textContent = `已生成示例谱面，原始约 ${beats.length} 个音符。`;
                }

                applyDifficultySettings();
                prepareNotes(beats, beatPeriod);
                gameState.totalNotes = gameState.notes.length;
                noteCountEl.textContent = gameState.totalNotes;
                startBtn.disabled = false;
                exportChartBtn.disabled = false;
                exportScoreBtn.disabled = true;
                resetScoreState();
            } catch (err) {
                console.error(err);
                infoText.textContent = "示例音频加载失败，请确认 example.mp3 是否放在同目录下。";
            }
        });

        // 频域节拍检测
        function generateBeatTimes(buffer) {
            const channelData = buffer.getChannelData(0);
            const sampleRate = buffer.sampleRate;

            const maxSecondsForAnalysis = 99999;
            const maxSamples = Math.min(channelData.length, maxSecondsForAnalysis * sampleRate);

            const frameSize = 2048;
            const hopSize = 1024;

            const bandFreqs = [80, 120, 200, 350, 600, 1000, 2000, 3500];
            const bandWeights = [2.0, 2.0, 1.6, 1.3, 1.0, 0.8, 0.6, 0.4];

            const numFrames = Math.floor((maxSamples - frameSize) / hopSize);
            if (numFrames <= 0) return { beats: [], beatPeriod: 0.5 };

            const flux = new Array(numFrames).fill(0);
            let prevMagnitudes = new Array(bandFreqs.length).fill(0);

            function goertzel(frame, offset, N, freq, sr) {
                const k = Math.round(0.5 + ((N * freq) / sr));
                const omega = (2 * Math.PI * k) / N;
                const cos = Math.cos(omega);
                const sin = Math.sin(omega);
                const coeff = 2 * cos;
                let q0 = 0, q1 = 0, q2 = 0;
                for (let i = 0; i < N; i++) {
                    q0 = coeff * q1 - q2 + frame[offset + i];
                    q2 = q1;
                    q1 = q0;
                }
                const real = q1 - q2 * cos;
                const imag = q2 * sin;
                return Math.sqrt(real * real + imag * imag);
            }

            for (let f = 0; f < numFrames; f++) {
                const offset = f * hopSize;
                const mags = [];
                for (let b = 0; b < bandFreqs.length; b++) {
                    const mag = goertzel(channelData, offset, frameSize, bandFreqs[b], sampleRate);
                    mags.push(mag);
                }
                let fluxValue = 0;
                for (let i = 0; i < mags.length; i++) {
                    const diff = mags[i] - prevMagnitudes[i];
                    if (diff > 0) fluxValue += diff * bandWeights[i];
                }
                flux[f] = fluxValue;
                prevMagnitudes = mags;
            }

            const smoothed = [];
            const smoothSize = 4;
            let maxFlux = 0;
            for (let i = 0; i < flux.length; i++) {
                let sum = 0, count = 0;
                for (let j = -smoothSize; j <= smoothSize; j++) {
                    const idx = i + j;
                    if (idx >= 0 && idx < flux.length) {
                        sum += flux[idx];
                        count++;
                    }
                }
                const v = count ? sum / count : 0;
                smoothed.push(v);
                if (v > maxFlux) maxFlux = v;
            }
            if (maxFlux <= 0) return { beats: [], beatPeriod: 0.5 };
            for (let i = 0; i < smoothed.length; i++) {
                smoothed[i] /= maxFlux;
            }

            const framesPerSecond = sampleRate / hopSize;

            const minTempo = 60;
            const maxTempo = 200;
            const minLag = Math.round(framesPerSecond * 60 / maxTempo);
            const maxLag = Math.round(framesPerSecond * 60 / minTempo);

            let bestLag = null;
            let bestScore = -Infinity;
            for (let lag = minLag; lag <= maxLag; lag++) {
                let score = 0;
                for (let i = 0; i + lag < smoothed.length; i++) {
                    score += smoothed[i] * smoothed[i + lag];
                }
                if (score > bestScore) {
                    bestScore = score;
                    bestLag = lag;
                }
            }
            if (!bestLag) return { beats: [], beatPeriod: 0.5 };

            let beatPeriod = bestLag / framesPerSecond;
            beatPeriod = Math.min(Math.max(beatPeriod, 0.25), 1.0);

            const beatWindow = beatPeriod * 0.25;
            const phaseStep = beatPeriod / 32;
            let bestPhase = 0;
            let bestPhaseScore = -Infinity;

            for (let phase = 0; phase < beatPeriod; phase += phaseStep) {
                let score = 0;
                for (let i = 0; i < smoothed.length; i++) {
                    const t = i / framesPerSecond;
                    const n = Math.round((t - phase) / beatPeriod);
                    const beatTime = phase + n * beatPeriod;
                    if (beatTime < 0) continue;
                    const dist = Math.abs(t - beatTime);
                    if (dist <= beatWindow) {
                        const w = 1 - dist / beatWindow;
                        score += smoothed[i] * w;
                    }
                }
                if (score > bestPhaseScore) {
                    bestPhaseScore = score;
                    bestPhase = phase;
                }
            }

            const duration = Math.min(buffer.duration, maxSecondsForAnalysis);
            const measureDuration = beatPeriod * 4;
            let firstMeasureStart = bestPhase;
            while (firstMeasureStart < 0) firstMeasureStart += measureDuration;
            if (firstMeasureStart > duration) firstMeasureStart = 0;

            const numMeasures = Math.max(
                1,
                Math.floor((duration - firstMeasureStart) / measureDuration)
            );

            const patterns = {
                low: [
                    [1, 0, 0, 0, 0, 0, 1, 0],
                    [1, 0, 0, 1, 0, 0, 1, 0],
                    [1, 0, 1, 0, 0, 0, 1, 0],
                ],
                mid: [
                    [1, 0, 0, 0, 1, 0, 1, 0],
                    [1, 0, 1, 0, 1, 0, 0, 1],
                    [1, 0, 1, 0, 1, 0, 1, 0],
                    [1, 0, 1, 1, 0, 0, 1, 0],
                ],
                high: [
                    [1, 1, 0, 1, 1, 0, 1, 0],
                    [1, 1, 0, 1, 1, 1, 1, 0],
                    [1, 0, 1, 1, 1, 0, 1, 1],
                    [1, 1, 1, 0, 1, 1, 0, 1],
                ]
            };

            const beats = [];
            const maxNotes = 99999;

            function snapToLocalPeak(timeSeconds) {
                const searchRadius = beatPeriod * 0.2;
                const startT = Math.max(0, timeSeconds - searchRadius);
                const endT = Math.min(duration, timeSeconds + searchRadius);

                const startIndex = Math.max(0, Math.floor(startT * framesPerSecond));
                const endIndex = Math.min(smoothed.length - 1, Math.ceil(endT * framesPerSecond));

                let bestIdx = null;
                let bestVal = -Infinity;
                for (let i = startIndex; i <= endIndex; i++) {
                    const v = smoothed[i];
                    if (v > bestVal) {
                        bestVal = v;
                        bestIdx = i;
                    }
                }
                if (bestIdx == null) return timeSeconds;
                return bestIdx / framesPerSecond;
            }

            for (let m = 0; m < numMeasures; m++) {
                const measureStart = firstMeasureStart + m * measureDuration;
                const measureEnd = measureStart + measureDuration;
                if (measureStart >= duration) break;

                let sum = 0, count = 0;
                const startIndex = Math.max(0, Math.floor(measureStart * framesPerSecond));
                const endIndex = Math.min(smoothed.length - 1, Math.ceil(measureEnd * framesPerSecond));
                for (let i = startIndex; i <= endIndex; i++) {
                    sum += smoothed[i];
                    count++;
                }
                const intensity = count ? sum / count : 0;

                let bucket = "mid";
                if (intensity < 0.25) bucket = "low";
                else if (intensity > 0.6) bucket = "high";

                const bucketPatterns = patterns[bucket];
                const pattern = bucketPatterns[Math.floor(Math.random() * bucketPatterns.length)];

                for (let s = 0; s < pattern.length; s++) {
                    if (!pattern[s]) continue;

                    const slotOffset = (beatPeriod / 2) * s;
                    let t = measureStart + slotOffset;
                    if (t < 0 || t > duration) continue;

                    const tFrame = Math.round(t * framesPerSecond);
                    const radiusFrames = Math.round(beatWindow * framesPerSecond);
                    let localSum = 0, localCount = 0;
                    for (let k = -radiusFrames; k <= radiusFrames; k++) {
                        const idx = tFrame + k;
                        if (idx >= 0 && idx < smoothed.length) {
                            localSum += smoothed[idx];
                            localCount++;
                        }
                    }
                    const localAvg = localCount ? localSum / localCount : 0;

                    if (localAvg < 0.4 && Math.random() < 0.15) {
                        continue;
                    }

                    const snappedTime = snapToLocalPeak(t);
                    beats.push(snappedTime);
                    if (beats.length >= maxNotes) break;
                }
                if (beats.length >= maxNotes) break;
            }

            if (beats.length === 0) {
                const fallbackBeats = [];
                const durationSafe = Math.min(buffer.duration, maxSecondsForAnalysis);
                for (let t = 0; t < durationSafe; t += beatPeriod) {
                    fallbackBeats.push(t);
                    if (fallbackBeats.length >= maxNotes) break;
                }
                return { beats: fallbackBeats, beatPeriod };
            }

            beats.sort((a, b) => a - b);
            const merged = [];
            const minGap = 0.02;
            for (let i = 0; i < beats.length; i++) {
                if (i === 0 || beats[i] - merged[merged.length - 1] > minGap) {
                    merged.push(beats[i]);
                }
            }
            return { beats: merged, beatPeriod };
        }

        // 构造更密集的节拍：插入中点，重复多轮用于 Hard/Master
        function buildDenseBeats(baseBeats, beatPeriod, level) {
            let current = baseBeats.slice();
            for (let iter = 0; iter < level; iter++) {
                const extra = [];
                for (let i = 0; i < current.length - 1; i++) {
                    const t1 = current[i];
                    const t2 = current[i + 1];
                    const gap = t2 - t1;
                    if (gap > beatPeriod * 0.35 && gap < beatPeriod * 2.4) {
                        extra.push(t1 + gap * 0.5);
                    }
                }
                current = current.concat(extra);
                current.sort((a, b) => a - b);

                // 稍微去重
                const merged = [];
                const minGap = beatPeriod * 0.14;
                for (let i = 0; i < current.length; i++) {
                    if (i === 0 || current[i] - merged[merged.length - 1] > minGap) {
                        merged.push(current[i]);
                    }
                }
                current = merged;
            }
            return current;
        }

        // 根据难度选出真正用来生成 note 的时间点
        function selectBeatsForDifficulty(baseBeats, beatPeriod) {
            const diff = getDifficulty();
            if (!baseBeats.length) return [];

            const normalBeats = baseBeats.slice();
            const normalCount = normalBeats.length;

            const ratioMap = {
                easy: 0.5,
                normal: 1.0,
                hard: 1.5,
                master: 2.0
            };
            const targetRatio = ratioMap[diff] || 1.0;
            let targetCount = Math.max(1, Math.round(normalCount * targetRatio));

            let source = normalBeats;

            if (diff === "easy") {
                // Easy：源节拍本身，最后再强制“相邻间隔 >= 1.2 beatPeriod”
                source = normalBeats;
            } else if (diff === "normal") {
                // Normal：仍用原节拍，只在太密时去掉部分
                source = normalBeats;
            } else if (diff === "hard") {
                // Hard：一轮加密
                source = buildDenseBeats(normalBeats, beatPeriod, 1);
            } else if (diff === "master") {
                // Master：再加密一轮，形成 8/16 分节奏感
                source = buildDenseBeats(normalBeats, beatPeriod, 2);
            }

            if (source.length <= targetCount) {
                targetCount = source.length;
                // 特殊处理 easy，让 pattern 更稀疏&规则
                if (diff === "easy") {
                    const result = [];
                    let lastT = -Infinity;
                    const minGapEasy = beatPeriod * 1.2;
                    for (let i = 0; i < source.length; i++) {
                        const t = source[i];
                        if (t - lastT >= minGapEasy) {
                            result.push(t);
                            lastT = t;
                        }
                    }
                    return result;
                }
                return source;
            }

            // 统一用“均匀采样”从 source 取 targetCount 个点
            const resultTemp = [];
            const step = source.length / targetCount;
            for (let i = 0; i < targetCount; i++) {
                const idx = Math.floor(i * step);
                if (idx >= 0 && idx < source.length) resultTemp.push(source[idx]);
            }

            // 针对 Easy 再做一次“至少间隔 1.2 beatPeriod”的修正，进一步拉大难度差距
            if (diff === "easy") {
                const result = [];
                let lastT = -Infinity;
                const minGapEasy = beatPeriod * 1.2;
                for (let i = 0; i < resultTemp.length; i++) {
                    const t = resultTemp[i];
                    if (t - lastT >= minGapEasy) {
                        result.push(t);
                        lastT = t;
                    }
                }
                return result;
            }

            // Normal：略微过滤特别密集的
            if (diff === "normal") {
                const result = [];
                let lastT = -Infinity;
                const minGapNormal = beatPeriod * 0.45;
                for (let i = 0; i < resultTemp.length; i++) {
                    const t = resultTemp[i];
                    if (t - lastT >= minGapNormal) {
                        result.push(t);
                        lastT = t;
                    }
                }
                return result;
            }

            // Hard / Master：保留密集感，只略微压掉极端重复
            const result = [];
            let lastT = -Infinity;
            const minGapDense = beatPeriod * 0.18;
            for (let i = 0; i < resultTemp.length; i++) {
                const t = resultTemp[i];
                if (t - lastT >= minGapDense) {
                    result.push(t);
                    lastT = t;
                }
            }
            return result;
        }

        // 生成相对平滑的判定区位置
        function chooseNotePosition(lastPos, margin) {
            const width = canvas.width;
            const height = canvas.height;
            const left = margin;
            const right = width - margin;
            const top = margin;
            const bottom = height - margin;

            if (!lastPos) {
                return {
                    x: left + Math.random() * (right - left),
                    y: top + Math.random() * (bottom - top),
                };
            }

            const diff = getDifficulty();
            // 难度越高，平均位移略大一点
            let minStep = 140;
            let maxStep = 260;
            if (diff === "easy") {
                minStep = 120;
                maxStep = 220;
            } else if (diff === "hard") {
                minStep = 160;
                maxStep = 280;
            } else if (diff === "master") {
                minStep = 170;
                maxStep = 320;
            }

            const angle = Math.random() * Math.PI * 2;
            const step = minStep + Math.random() * (maxStep - minStep);
            let x = lastPos.x + Math.cos(angle) * step;
            let y = lastPos.y + Math.sin(angle) * step;

            x = Math.min(right, Math.max(left, x));
            y = Math.min(bottom, Math.max(top, y));
            return { x, y };
        }

        // 谱面生成（无 hold）
        function prepareNotes(beats, beatPeriod) {
            const selectedBeats = selectBeatsForDifficulty(beats, beatPeriod);
            gameState.notes = [];

            const margin = 110;
            const baseRadius = 40;
            const approach = gameState.approachTime;

            let lastPos = null;
            let prevNote = null;

            for (let i = 0; i < selectedBeats.length; i++) {
                const t = selectedBeats[i];
                const spawnTime = t - approach;
                const pos = chooseNotePosition(lastPos, margin);
                lastPos = pos;

                const angle = Math.random() * Math.PI * 2;
                const distance = Math.max(canvas.width, canvas.height) * 0.7;
                const spawnX = pos.x + Math.cos(angle) * distance;
                const spawnY = pos.y + Math.sin(angle) * distance;
                const radius = baseRadius * (0.9 + Math.random() * 0.3);

                const note = {
                    targetTime: t,
                    spawnTime: spawnTime < 0 ? 0 : spawnTime,
                    x: pos.x,
                    y: pos.y,
                    radius,
                    spawnX,
                    spawnY,
                    hit: false,
                    missed: false,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() * 2 - 1) * 1.5,
                    trail: [],
                    prevOutline: prevNote,
                    isGold: false,
                    weight: 1
                };

                gameState.notes.push(note);
                prevNote = note;
            }

            // 金色音符：根据难度比例
            const n = gameState.notes.length;
            if (n > 0) {
                const diff = getDifficulty();
                const goldRatio =
                    diff === "easy" ? 0.06 :
                        diff === "normal" ? 0.09 :
                            diff === "hard" ? 0.13 :
                                0.18; // master
                const goldTarget = Math.max(1, Math.round(n * goldRatio));

                const indices = [...Array(n).keys()];
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }
                for (let i = 0; i < goldTarget && i < indices.length; i++) {
                    const idx = indices[i];
                    gameState.notes[idx].isGold = true;
                    gameState.notes[idx].weight = 3;
                }
            }

            gameState.notes.sort((a, b) => a.targetTime - b.targetTime);

            // 计算总权重
            let totalWeight = 0;
            for (const nNote of gameState.notes) {
                totalWeight += nNote.weight || 1;
            }
            gameState.totalWeight = totalWeight || 1;
        }

        // 游戏控制
        startBtn.addEventListener("click", async () => {
            if (!gameState.buffer || !gameState.audioCtx) return;
            enterGameplayScreen();
            await enterFullscreen();
            startGame();
        });

        function enterGameplayScreen() {
            document.body.style.overflow = "hidden";
            document.querySelector("h1").style.display = "none";
            document.querySelector(".panel").style.display = "none";
            document.querySelector(".info").style.display = "none";
            document.querySelector(".stats").style.display = "none";
            document.querySelector(".judge-stats").style.display = "none";
            document.querySelector(".hint").style.display = "none";
            offsetStatsEl.style.display = "none";
            document.getElementById("gameContainer").classList.add("fullscreen-play");
        }

        function exitGameplayScreen() {
            document.body.style.overflow = "auto";
            document.querySelector("h1").style.display = "";
            document.querySelector(".panel").style.display = "";
            document.querySelector(".info").style.display = "";
            document.querySelector(".stats").style.display = "";
            document.querySelector(".judge-stats").style.display = "";
            document.querySelector(".hint").style.display = "";
            offsetStatsEl.style.display = "";
            document.getElementById("gameContainer").classList.remove("fullscreen-play");
        }

        function startGame() {
            const audioCtx = gameState.audioCtx;
            if (gameState.source) {
                try { gameState.source.stop(); } catch { }
            }
            const source = audioCtx.createBufferSource();
            source.buffer = gameState.buffer;
            source.connect(audioCtx.destination);
            source.start();

            gameState.source = source;
            gameState.startTime = audioCtx.currentTime;
            gameState.isPlaying = true;

            resetScoreState();

            for (const n of gameState.notes) {
                n.hit = false;
                n.missed = false;
                n.trail = [];
            }
        }

        function resetScoreState() {
            gameState.scoreValue = 0;
            gameState.combo = 0;
            gameState.maxCombo = 0;
            gameState.perfectCount = 0;
            gameState.goodCount = 0;
            gameState.badCount = 0;
            gameState.missCount = 0;
            gameState.currentScorePercent = 0;
            gameState.currentGrade = "D";
            gameState.currentGradeLevel = 0;
            gameState.lastJudgement = "";
            gameState.hitEffects = [];
            gameState.hitOffsets = [];
            judgementTextEl.textContent = "";
            judgementTextEl.style.transform = "scale(1)";
            if (offsetStatsEl) offsetStatsEl.textContent = "";

            updateScoreAndUI();
        }

        // 判定（键盘）
        window.addEventListener("keydown", (e) => {
            if (e.code === "Space") {
                e.preventDefault();
                handleHit();
            }
        });

        // 不同难度判定线
        function judgeHit(absTimeDiff, distRatio) {
            const diff = getDifficulty();

            // Normal 基准
            let tPerfect = 0.08;
            let tGood = 0.16;
            let tBad = 0.26;

            let dPerfect = 0.45;
            let dGood = 0.85;
            let dBad = 1.20;

            if (diff === "easy") {
                const tf = 1.5;
                const df = 1.3;
                tPerfect *= tf;
                tGood *= tf;
                tBad *= tf;
                dPerfect *= df;
                dGood *= df;
                dBad *= df;
            } else if (diff === "hard") {
                const tf = 0.75;
                const df = 0.8;
                tPerfect *= tf;
                tGood *= tf;
                tBad *= tf;
                dPerfect *= df;
                dGood *= df;
                dBad *= df;
            } else if (diff === "master") {
                const tf = 0.6;
                const df = 0.75;
                tPerfect *= tf;
                tGood *= tf;
                tBad *= tf;
                dPerfect *= df;
                dGood *= df;
                dBad *= df;
            }

            if (absTimeDiff <= tPerfect && distRatio <= dPerfect) return "PERFECT";
            if (absTimeDiff <= tGood && distRatio <= dGood) return "GOOD";
            if (absTimeDiff <= tBad && distRatio <= dBad) return "BAD";
            return "MISS";
        }

        function handleTapScreen(clientX, clientY) {
            if (!gameState.isPlaying || !gameState.audioCtx) return;
            const now = gameState.audioCtx.currentTime - gameState.startTime;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;

            let bestNote = null;
            let bestScore = Infinity;
            let bestTimeDiff = 0;
            let bestDistRatio = 0;

            for (const note of gameState.notes) {
                if (note.hit || note.missed) continue;

                const dt = now - note.targetTime;
                const adt = Math.abs(dt);
                if (adt > 0.32) continue;

                const pos = getNotePosition(note, now);
                const dist = Math.hypot(pos.x - x, pos.y - y);
                const distRatio = dist / note.radius;
                if (distRatio > 1.8) continue;

                const score = adt * 1.0 + distRatio * 0.06;
                if (score < bestScore) {
                    bestScore = score;
                    bestNote = note;
                    bestTimeDiff = dt;
                    bestDistRatio = distRatio;
                }
            }

            if (!bestNote) {
                applyJudgement(null, "MISS", 0);
                return;
            }

            const offset = bestTimeDiff;
            const result = judgeHit(Math.abs(offset), bestDistRatio);

            if (result === "MISS") {
                bestNote.missed = true;
            } else {
                bestNote.hit = true;
            }

            applyJudgement(bestNote, result, offset);
        }

        function handleHit() {
            if (!gameState.isPlaying || !gameState.audioCtx) return;
            const now = gameState.audioCtx.currentTime - gameState.startTime;

            let bestNote = null;
            let bestDiff = Infinity;

            for (const note of gameState.notes) {
                if (note.hit || note.missed) continue;
                const diff = now - note.targetTime;
                const ad = Math.abs(diff);
                if (ad > 0.3) continue;
                if (ad < bestDiff) {
                    bestDiff = ad;
                    bestNote = note;
                }
            }

            if (!bestNote) {
                applyJudgement(null, "MISS", 0);
                return;
            }

            const currentPos = getNotePosition(bestNote, now);
            const dist = Math.hypot(currentPos.x - bestNote.x, currentPos.y - bestNote.y);
            const distRatio = dist / bestNote.radius;

            const offset = now - bestNote.targetTime;
            const result = judgeHit(Math.abs(offset), distRatio);

            if (result === "MISS") {
                bestNote.missed = true;
            } else {
                bestNote.hit = true;
            }

            applyJudgement(bestNote, result, offset);
        }

        function applyJudgement(note, result, offsetSeconds = 0) {
            let ratio = 0;
            if (result === "PERFECT") ratio = 1.0;
            else if (result === "GOOD") ratio = 0.7;
            else if (result === "BAD") ratio = 0.4;
            else ratio = 0;

            if (note && result !== "MISS") {
                const w = note.weight || 1;
                gameState.scoreValue += ratio * w;
                gameState.hitOffsets.push(offsetSeconds);
            }

            if (result === "PERFECT") gameState.perfectCount++;
            else if (result === "GOOD") gameState.goodCount++;
            else if (result === "BAD") gameState.badCount++;
            else gameState.missCount++;

            // 只有 PERFECT/GOOD 维持连击；BAD/MISS 断
            if (result === "PERFECT" || result === "GOOD") {
                gameState.combo += 1;
                if (gameState.combo > gameState.maxCombo) {
                    gameState.maxCombo = gameState.combo;
                }
            } else {
                gameState.combo = 0;
            }

            registerJudgement(result, note && note.isGold);
            if (note) {
                spawnHitEffect(note.x, note.y, result, note.isGold);
            }
            playHitSound(result, note && note.isGold);

            updateScoreAndUI();
        }

        function registerJudgement(text, isGold = false) {
            gameState.lastJudgement = isGold ? (text + "+") : text;
            gameState.lastJudgementTime = performance.now() / 1000;
        }

        function getGradeFromPercent(p) {
            if (p > 100) return { label: "SSS+", level: 9 };
            if (p >= 99.75) return { label: "SSS", level: 8 };
            if (p >= 99.5) return { label: "SS+", level: 7 };
            if (p >= 99) return { label: "SS", level: 6 };
            if (p >= 98) return { label: "S+", level: 5 };
            if (p >= 97) return { label: "S", level: 4 };
            if (p >= 90) return { label: "A", level: 3 };
            if (p >= 80) return { label: "B", level: 2 };
            if (p >= 60) return { label: "C", level: 1 };
            return { label: "D", level: 0 };
        }

        function updateOffsetStats() {
            if (!offsetStatsEl) return;
            const arr = gameState.hitOffsets;
            if (!arr.length) {
                offsetStatsEl.textContent = "";
                return;
            }
            const sum = arr.reduce((a, b) => a + b, 0);
            const avg = sum / arr.length;
            const sumSq = arr.reduce((a, b) => a + (b - avg) * (b - avg), 0);
            const std = Math.sqrt(sumSq / arr.length);

            const avgMs = avg * 1000;
            const stdMs = std * 1000;
            const tendency =
                avgMs > 1 ? "偏晚" : avgMs < -1 ? "偏早" : "基本居中";

            offsetStatsEl.textContent =
                `判定偏差：平均 ${avgMs.toFixed(1)} ms（${tendency}），` +
                `离散度 ${stdMs.toFixed(1)} ms，共命中 ${arr.length} 个 note`;
        }

        function updateScoreAndUI() {
            const totalW = gameState.totalWeight || 1;
            const rawAccuracy = gameState.scoreValue / totalW;
            let basePercent = rawAccuracy * 100;
            if (basePercent < 0) basePercent = 0;

            const total = gameState.totalNotes || 1;
            const comboBonus = (gameState.maxCombo / total) * 2;
            let finalPercent = basePercent + comboBonus;

            gameState.currentScorePercent = finalPercent;
            const gradeInfo = getGradeFromPercent(finalPercent);
            gameState.currentGrade = gradeInfo.label;
            gameState.currentGradeLevel = gradeInfo.level;

            scorePercentEl.textContent = finalPercent.toFixed(4) + "%";
            scoreGradeEl.textContent = gradeInfo.label;
            comboEl.textContent = gameState.combo;
            maxComboEl.textContent = gameState.maxCombo;

            countPerfectEl.textContent = gameState.perfectCount;
            countGoodEl.textContent = gameState.goodCount;
            countBadEl.textContent = gameState.badCount;
            countMissEl.textContent = gameState.missCount;

            centreScoreEl.textContent = finalPercent.toFixed(4) + "% [" + gradeInfo.label + "]";
            centreComboEl.textContent = "Combo " + gameState.combo;

            updateOffsetStats();
        }

        function findNextTargetNote(nowAudio) {
            let bestNote = null;
            let bestScore = Infinity;

            for (const note of gameState.notes) {
                if (note.hit || note.missed) continue;
                const dt = note.targetTime - nowAudio;
                if (dt < -0.25 || dt > 3) continue;
                const score = Math.abs(dt);
                if (score < bestScore) {
                    bestScore = score;
                    bestNote = note;
                }
            }
            return bestNote;
        }

        function getNotePosition(note, audioTime) {
            const t = (audioTime - note.spawnTime) / gameState.approachTime;
            const progress = Math.min(Math.max(t, 0), 1.3);
            return {
                x: note.spawnX + (note.x - note.spawnX) * progress,
                y: note.spawnY + (note.y - note.spawnY) * progress,
                progress
            };
        }

        function playHitSound(result, isGold = false) {
            if (!gameState.audioCtx) return;
            const ctxAudio = gameState.audioCtx;

            const osc = ctxAudio.createOscillator();
            const clickOsc = ctxAudio.createOscillator();
            const gain = ctxAudio.createGain();
            const clickGain = ctxAudio.createGain();

            let freq = 900;
            let baseGain = 0.22;
            let duration = 0.07;

            if (result === "PERFECT") {
                freq = isGold ? 1350 : 1200;
                baseGain = 0.26;
                duration = 0.06;
            } else if (result === "GOOD") {
                freq = isGold ? 1100 : 1000;
                baseGain = 0.25;
                duration = 0.07;
            } else if (result === "BAD") {
                freq = 650;
                baseGain = 0.28;
                duration = 0.09;
            } else {
                freq = 420;
                baseGain = 0.20;
                duration = 0.06;
            }

            const gradeLevel = gameState.currentGradeLevel || 0;
            const volumeFactor = Math.max(0.35, 1 - gradeLevel * 0.06);
            baseGain *= volumeFactor * (isGold ? 1.15 : 1.0);

            osc.frequency.value = freq;
            osc.type = "square";

            clickOsc.frequency.value = 2600;
            clickOsc.type = "triangle";

            const now = ctxAudio.currentTime;

            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(baseGain, now + 0.005);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

            clickGain.gain.setValueAtTime(baseGain * 0.6, now);
            clickGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.6);

            osc.connect(gain);
            clickOsc.connect(clickGain);
            gain.connect(ctxAudio.destination);
            clickGain.connect(ctxAudio.destination);

            osc.start(now);
            clickOsc.start(now);
            osc.stop(now + duration + 0.02);
            clickOsc.stop(now + duration + 0.05);
        }

        function spawnHitEffect(x, y, type, isGold = false) {
            const now = performance.now() / 1000;

            let baseColor = "255,255,255";
            if (type === "GOOD") baseColor = "190, 242, 100";
            else if (type === "BAD") baseColor = "251, 191, 36";
            else if (type === "MISS") baseColor = "248, 113, 113";

            if (isGold) {
                baseColor = "252, 211, 77";
            }

            const gradeScale = 1 + (gameState.currentGradeLevel || 0) * 0.08;
            let baseScale = 1;
            let duration = 0.35;
            let rings = 2;
            let particles = 14;

            if (type === "PERFECT") {
                baseScale = 1.3;
                duration = 0.45;
                rings = isGold ? 4 : 3;
                particles = isGold ? 26 : 22;
            } else if (type === "GOOD") {
                baseScale = 1.0;
                duration = 0.35;
            } else if (type === "BAD") {
                baseScale = 0.85;
                duration = 0.30;
                particles = 10;
            } else {
                baseScale = 0.7;
                duration = 0.25;
                particles = 8;
            }

            if (isGold) {
                baseScale *= 1.15;
            }

            const scale = baseScale * gradeScale;

            const particleList = [];
            for (let i = 0; i < particles; i++) {
                particleList.push({
                    angle: (i / particles) * Math.PI * 2 + Math.random() * 0.3,
                    speed: 80 + Math.random() * 120,
                    radius: 4 + Math.random() * 4,
                });
            }

            gameState.hitEffects.push({
                x,
                y,
                startTime: now,
                duration,
                color: baseColor,
                scale,
                rings,
                particles: particleList,
                isGold
            });
        }

        function drawHitEffects(now) {
            ctx.save();
            for (let i = gameState.hitEffects.length - 1; i >= 0; i--) {
                const e = gameState.hitEffects[i];
                const t = (now - e.startTime) / e.duration;
                if (t >= 1) {
                    gameState.hitEffects.splice(i, 1);
                    continue;
                }

                const alpha = 1 - t;

                for (let rIndex = 0; rIndex < e.rings; rIndex++) {
                    const ringT = t * (0.7 + rIndex * 0.2);
                    const radius = (16 + ringT * 90) * e.scale;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(${e.color}, ${alpha * (0.6 - rIndex * 0.15)})`;
                    ctx.lineWidth = 3 * (1 - ringT);
                    ctx.stroke();
                }

                for (const p of e.particles) {
                    const dist = p.speed * t * e.scale;
                    const px = e.x + Math.cos(p.angle) * dist;
                    const py = e.y + Math.sin(p.angle) * dist;
                    ctx.beginPath();
                    ctx.arc(px, py, p.radius * (1 - t), 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${e.color}, ${alpha})`;
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        function drawJudgement(now) {
            if (!gameState.lastJudgement) {
                judgementTextEl.textContent = "";
                judgementTextEl.style.transform = "scale(1)";
                return;
            }
            const elapsed = now - gameState.lastJudgementTime;
            const duration = 0.9;
            if (elapsed > duration) {
                gameState.lastJudgement = "";
                judgementTextEl.textContent = "";
                judgementTextEl.style.transform = "scale(1)";
                return;
            }

            const t = elapsed / duration;
            const scale = 1 + 0.6 * (1 - t);
            const opacity = 1 - t;

            judgementTextEl.textContent = gameState.lastJudgement;
            judgementTextEl.style.transform = `scale(${scale})`;
            const txt = gameState.lastJudgement;
            const isGold = txt.endsWith("+");
            const base = isGold ? "252, 211, 77" : (
                txt.startsWith("PERFECT") ? "248,250,252" :
                    txt.startsWith("GOOD") ? "190,242,100" :
                        txt.startsWith("BAD") ? "251,191,36" :
                            "248,113,113"
            );
            judgementTextEl.style.color = `rgba(${base}, ${opacity})`;
        }

        function drawBackground(deltaTime) {
            ctx.save();
            ctx.fillStyle = "rgba(2,6,23,0.9)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (const c of gameState.bgCircles) {
                c.y -= c.speed * deltaTime * 60;
                if (c.y + c.r < 0) {
                    c.y = canvas.height + c.r;
                    c.x = Math.random() * canvas.width;
                }
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(148,163,184,${c.alpha})`;
                ctx.fill();
            }
            ctx.restore();
        }

        function drawChainLine(note, targetNote, nowAudio) {
            const prev = note.prevOutline;
            if (!prev) return;

            const appear1 = prev.spawnTime;
            const disappear1 = prev.targetTime + OUTLINE_HIDE_AFTER;
            const appear2 = note.spawnTime;
            const disappear2 = note.targetTime + OUTLINE_HIDE_AFTER;

            const appear = Math.max(appear1, appear2);
            const disappear = Math.min(disappear1, disappear2);

            if (nowAudio < appear || nowAudio > disappear) return;

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(prev.x, prev.y);
            ctx.lineTo(note.x, note.y);

            const isCurrentPath = (note === targetNote || prev === targetNote);
            ctx.strokeStyle = isCurrentPath
                ? "rgba(236,252,203,0.7)"
                : "rgba(148,163,184,0.25)";
            ctx.lineWidth = isCurrentPath ? 3 : 2;
            ctx.setLineDash(isCurrentPath ? [10, 6] : [3, 10]);
            ctx.stroke();
            ctx.restore();
        }

        function drawOutlineAndJudgeRing(note, audioTime, targetNote) {
            if (note.hit || note.missed) return;

            const appearTime = note.spawnTime;
            const disappearTime = note.targetTime + OUTLINE_HIDE_AFTER;

            if (audioTime < appearTime || audioTime > disappearTime) {
                return;
            }

            const isTarget = (note === targetNote);

            ctx.save();

            ctx.lineWidth = isTarget ? 5 : 3;
            const baseAlpha = isTarget ? 0.95 : 0.55;

            if (note.isGold) {
                ctx.strokeStyle = isTarget
                    ? `rgba(252, 211, 77, ${baseAlpha})`
                    : `rgba(252, 211, 77, 0.7)`;
            } else {
                ctx.strokeStyle = isTarget
                    ? "rgba(244,244,255,0.95)"
                    : `rgba(148,163,255,${baseAlpha})`;
            }

            const sides = 4 + ((note.x + note.y) | 0) % 3;
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                const r = note.radius * (isTarget ? 1.25 : 1.1);
                const px = note.x + Math.cos(angle) * r;
                const py = note.y + Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.stroke();

            const dt = note.targetTime - audioTime;
            const remaining = Math.min(Math.max(dt, 0), OUTLINE_SHOW_BEFORE);
            const k = OUTLINE_SHOW_BEFORE > 0 ? remaining / OUTLINE_SHOW_BEFORE : 0;
            const scale = 1 + 1.4 * k;
            const ringRadius = note.radius * scale * 1.1;
            const ringAlpha = (isTarget ? 0.4 : 0.2) + (1 - k) * (isTarget ? 0.6 : 0.5);

            ctx.beginPath();
            ctx.arc(note.x, note.y, ringRadius, 0, Math.PI * 2);
            if (note.isGold) {
                ctx.strokeStyle = isTarget
                    ? `rgba(253, 224, 71,${ringAlpha})`
                    : `rgba(250, 204, 21,${ringAlpha * 0.9})`;
            } else {
                ctx.strokeStyle = isTarget
                    ? `rgba(244,244,255,${ringAlpha})`
                    : `rgba(248,250,252,${ringAlpha})`;
            }
            ctx.lineWidth = isTarget ? 3 : 2;
            ctx.setLineDash(isTarget ? [2, 8] : [6, 10]);
            ctx.stroke();

            ctx.restore();
        }

        function drawNote(note, audioTime, deltaTime, targetNote) {
            if (note.hit || note.missed) return;

            const pos = getNotePosition(note, audioTime);
            if (pos.progress <= 0) return;
            if (pos.progress > 1.3) {
                if (!note.hit && !note.missed) {
                    note.missed = true;
                    note.trail = [];
                    applyJudgement(note, "MISS", 0);
                }
                return;
            }

            const isTarget = (note === targetNote);

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            ctx.lineTo(note.x, note.y);
            const gradientLine = ctx.createLinearGradient(pos.x, pos.y, note.x, note.y);
            if (note.isGold) {
                gradientLine.addColorStop(0, "rgba(253,224,71,0.95)");
                gradientLine.addColorStop(1, "rgba(245,158,11,0.0)");
            } else if (isTarget) {
                gradientLine.addColorStop(0, "rgba(248,250,252,0.95)");
                gradientLine.addColorStop(1, "rgba(129,140,248,0.0)");
            } else {
                gradientLine.addColorStop(0, "rgba(96,165,250,0.8)");
                gradientLine.addColorStop(1, "rgba(148,163,255,0.0)");
            }
            ctx.strokeStyle = gradientLine;
            ctx.lineWidth = isTarget ? 3 : 2;
            ctx.setLineDash(isTarget ? [2, 10] : [4, 12]);
            ctx.stroke();
            ctx.restore();

            note.trail.push({ x: pos.x, y: pos.y });
            if (note.trail.length > 18) note.trail.shift();

            ctx.save();
            ctx.lineJoin = "round";
            ctx.lineCap = "round";

            for (let i = 0; i < note.trail.length; i++) {
                const p = note.trail[i];
                const alpha = (i + 1) / note.trail.length;
                ctx.beginPath();
                ctx.arc(p.x, p.y, note.radius * 0.5 * (i / note.trail.length), 0, Math.PI * 2);
                if (note.isGold) {
                    ctx.fillStyle = `rgba(252, 211, 77,${alpha * 0.45})`;
                } else {
                    ctx.fillStyle = isTarget
                        ? `rgba(248,250,252,${alpha * 0.45})`
                        : `rgba(96,165,250,${alpha * 0.35})`;
                }
                ctx.fill();
            }

            const p = Math.min(Math.max(pos.progress, 0), 1);
            let sizeScale = 0.85 + 0.35 * Math.sin(p * Math.PI * 0.5);
            if (isTarget) sizeScale *= 1.08;
            const drawRadius = note.radius * sizeScale;

            note.rotation += note.rotationSpeed * deltaTime;

            ctx.translate(pos.x, pos.y);
            ctx.rotate(note.rotation);

            const gradient = ctx.createRadialGradient(
                0, 0, drawRadius * 0.2,
                0, 0, drawRadius
            );
            if (note.isGold) {
                gradient.addColorStop(0, "rgba(255, 249, 196,1.0)");
                gradient.addColorStop(0.35, "rgba(253, 224, 71,0.95)");
                gradient.addColorStop(1, "rgba(245, 158, 11,0.9)");
            } else if (isTarget) {
                gradient.addColorStop(0, "rgba(248,250,252,1.0)");
                gradient.addColorStop(0.35, "rgba(191,219,254,0.95)");
                gradient.addColorStop(1, "rgba(129,140,248,0.9)");
            } else {
                gradient.addColorStop(0, "rgba(248,250,252,0.95)");
                gradient.addColorStop(0.4, "rgba(129,140,248,0.9)");
                gradient.addColorStop(1, "rgba(236,72,153,0.7)");
            }

            ctx.beginPath();
            const sides = 4 + ((note.x + note.y) | 0) % 3;
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                const r = drawRadius * (0.8 + (i % 2) * 0.2);
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.lineWidth = isTarget ? 3 : 2;
            if (note.isGold) {
                ctx.strokeStyle = "rgba(15, 23, 42, 0.95)";
            } else {
                ctx.strokeStyle = isTarget
                    ? "rgba(15,23,42,1)"
                    : "rgba(15,23,42,0.9)";
            }
            ctx.stroke();

            ctx.restore();
        }

        // 导出谱面
        function exportChart() {
            if (!gameState.notes || !gameState.notes.length) return;

            const data = {
                version: 2,
                difficulty: getDifficulty(),
                approachTime: gameState.approachTime,
                beatPeriod: gameState.lastBeatPeriod || 0.5,
                notes: gameState.notes.map((n) => ({
                    t: n.targetTime,
                    x: +(n.x / canvas.width).toFixed(4),
                    y: +(n.y / canvas.height).toFixed(4),
                    r: +(n.radius / Math.min(canvas.width, canvas.height)).toFixed(4),
                    gold: !!n.isGold,
                    weight: n.weight || 1
                })),
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `chart_${getDifficulty()}.json`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }
        exportChartBtn.addEventListener("click", exportChart);

        // 导出成绩图
        function exportScoreImage() {
            const total = gameState.totalNotes || 1;
            if (!total) return;

            const canvasOut = document.createElement("canvas");
            canvasOut.width = 800;
            canvasOut.height = 450;
            const c = canvasOut.getContext("2d");

            const grad = c.createLinearGradient(0, 0, 800, 450);
            grad.addColorStop(0, "#0f172a");
            grad.addColorStop(1, "#4f46e5");
            c.fillStyle = grad;
            c.fillRect(0, 0, 800, 450);

            c.fillStyle = "#e5e7eb";
            c.font = "20px system-ui";
            c.fillText("图形节奏音乐游戏 - 成绩单", 40, 60);

            c.font = "80px system-ui";
            c.fillStyle = "#fbbf24";
            c.fillText(gameState.currentGrade, 40, 160);

            c.font = "26px system-ui";
            c.fillStyle = "#e5e7eb";
            c.fillText("Difficulty: " + getDifficulty(), 40, 200);

            c.font = "40px system-ui";
            c.fillStyle = "#f9fafb";
            c.fillText(gameState.currentScorePercent.toFixed(4) + "%", 40, 250);

            c.font = "22px system-ui";
            c.fillStyle = "#e5e7eb";
            const lineY = 290;
            c.fillText(`Max Combo: ${gameState.maxCombo}`, 40, lineY);
            c.fillText(`PERFECT: ${gameState.perfectCount}`, 40, lineY + 32);
            c.fillText(`GOOD: ${gameState.goodCount}`, 40, lineY + 64);
            c.fillText(`BAD: ${gameState.badCount}`, 270, lineY + 32);
            c.fillText(`MISS: ${gameState.missCount}`, 270, lineY + 64);
            c.fillText(`Notes: ${gameState.totalNotes}`, 270, lineY);

            if (gameState.hitOffsets && gameState.hitOffsets.length) {
                const arr = gameState.hitOffsets;
                const avg = arr.reduce((a, b) => a + b, 0) / arr.length;
                const sumSq = arr.reduce((a, b) => a + (b - avg) * (b - avg), 0);
                const std = Math.sqrt(sumSq / arr.length);
                const avgMs = avg * 1000;
                const stdMs = std * 1000;
                const text = `平均偏差: ${avgMs.toFixed(1)} ms, 离散度: ${stdMs.toFixed(1)} ms`;
                c.fillText(text, 40, 380);
            }

            const url = canvasOut.toDataURL("image/png");
            const a = document.createElement("a");
            a.href = url;
            a.download = `score_${getDifficulty()}.png`;
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        exportScoreBtn.addEventListener("click", exportScoreImage);

        // 主循环
        let lastFrameTime = performance.now();
        function loop() {
            requestAnimationFrame(loop);
            const nowPerf = performance.now();
            const deltaMs = nowPerf - lastFrameTime;
            lastFrameTime = nowPerf;
            const deltaTime = deltaMs / 1000;

            const nowAudio =
                gameState.isPlaying && gameState.audioCtx
                    ? gameState.audioCtx.currentTime - gameState.startTime
                    : 0;

            const targetNote = findNextTargetNote(nowAudio);

            drawBackground(deltaTime);

            for (const note of gameState.notes) {
                drawChainLine(note, targetNote, nowAudio);
            }

            for (const note of gameState.notes) {
                drawOutlineAndJudgeRing(note, nowAudio, targetNote);
            }

            for (const note of gameState.notes) {
                drawNote(note, nowAudio, deltaTime, targetNote);
            }

            gameState.notes = gameState.notes.filter(n => {
                if (!n.missed) return true;
                return nowAudio - n.targetTime < 2;
            });

            drawHitEffects(nowPerf / 1000);
            drawJudgement(nowPerf / 1000);

            if (
                gameState.isPlaying &&
                gameState.buffer &&
                nowAudio > gameState.buffer.duration + 0.3
            ) {
                gameState.isPlaying = false;
                exitGameplayScreen();
                exitFullscreen();
                infoText.textContent = "本曲结束。可重新点击“开始游戏”再玩一次，或导出谱面 / 成绩图。";
                exportScoreBtn.disabled = false;
                exportChartBtn.disabled = false;
            }
        }
        loop();
    </script>
</body>

</html>
