<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <title>节奏图形音乐游戏 Demo</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: radial-gradient(circle at top, #1b1f3a, #050710);
            color: #f5f5f5;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding: 16px;
            overflow: hidden;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 8px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .panel {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .panel label {
            font-size: 14px;
            opacity: 0.8;
        }

        input[type="file"] {
            font-size: 13px;
            max-width: 260px;
        }

        button {
            border: none;
            padding: 8px 16px;
            border-radius: 999px;
            font-size: 14px;
            cursor: pointer;
            background: linear-gradient(135deg, #4f46e5, #ec4899);
            color: white;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
            transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease;
        }

        button:disabled {
            opacity: 0.4;
            cursor: default;
            box-shadow: none;
            filter: grayscale(0.3);
        }

        button:not(:disabled):hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.45);
            filter: brightness(1.05);
        }

        .info {
            font-size: 13px;
            opacity: 0.75;
            margin-bottom: 8px;
            text-align: center;
        }

        .stats {
            display: flex;
            gap: 14px;
            font-size: 13px;
            margin-bottom: 4px;
            align-items: baseline;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stats span.label {
            opacity: 0.7;
            margin-right: 4px;
        }

        .stats .value {
            font-weight: 600;
        }

        .judge-stats {
            display: flex;
            gap: 12px;
            font-size: 12px;
            margin-bottom: 6px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .judge-stats span {
            opacity: 0.85;
        }

        .judge-stats .perfect {
            color: #fef9c3;
        }

        .judge-stats .good {
            color: #bbf7d0;
        }

        .judge-stats .bad {
            color: #fed7aa;
        }

        .judge-stats .miss {
            color: #fecaca;
        }

        .hint {
            margin-top: 2px;
            font-size: 12px;
            opacity: 0.6;
            text-align: center;
            margin-bottom: 6px;
        }

        .game-wrapper {
            position: relative;
            display: inline-block;
        }

        canvas {
            border-radius: 20px;
            box-shadow: 0 20px 70px rgba(0, 0, 0, 0.7);
            background: radial-gradient(circle at bottom, #020617, #030712 55%, #020617 100%);
            max-width: 100%;
            display: block;
        }

        .center-hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            text-shadow: 0 0 12px rgba(0, 0, 0, 0.8);
        }

        .center-score {
            font-size: 20px;
            margin-bottom: 4px;
            letter-spacing: 1px;
        }

        .center-combo {
            font-size: 16px;
            margin-bottom: 4px;
            opacity: 0.9;
        }

        .center-judge {
            min-height: 28px;
            font-size: 22px;
            font-weight: bold;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        /* 全屏模式下的游戏容器 */
        .fullscreen-play {
            position: fixed !important;
            inset: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999;
            background: #000;
            margin: 0 !important;
            padding: 0 !important;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* 全屏时 canvas 改为自动适配居中缩放 */
        .fullscreen-play canvas {
            width: 100vw !important;
            height: 100vh !important;
            object-fit: contain;
        }
    </style>
</head>

<body>
    <h1>图形节奏音乐游戏</h1>

    <div class="panel">
        <label>
            选择 MP3：
            <input type="file" id="fileInput" accept="audio/mpeg,audio/mp3" />
        </label>
        <button id="startBtn" disabled>开始游戏</button>
    </div>

    <div class="info" id="infoText">
        请选择一首 mp3，程序会用频域分析 + pattern 自动生成节奏谱面。<br />
        游戏中：图形对齐轮廓 + 判定环收缩到目标时按下 <b>空格</b>。
    </div>

    <div class="stats">
        <div>
            <span class="label">Score</span>
            <span class="value" id="scorePercent">0.0000%</span>
        </div>
        <div>
            <span class="label">Grade</span>
            <span class="value" id="scoreGrade">D</span>
        </div>
        <div>
            <span class="label">Combo</span>
            <span class="value" id="combo">0</span>
        </div>
        <div>
            <span class="label">Max Combo</span>
            <span class="value" id="maxCombo">0</span>
        </div>
        <div>
            <span class="label">Notes</span>
            <span class="value" id="noteCount">0</span>
        </div>
    </div>

    <div class="judge-stats">
        <span class="perfect">PERFECT: <span id="countPerfect">0</span></span>
        <span class="good">GOOD: <span id="countGood">0</span></span>
        <span class="bad">BAD: <span id="countBad">0</span></span>
        <span class="miss">MISS: <span id="countMiss">0</span></span>
    </div>

    <div class="hint">
        分数以 100.0000% 为基准，每个 note 平分：GOOD = PERFECT 的 2/3，BAD = 1/3，MISS = 0。<br />
        额外根据最大连击加最多 +2% 加成，可突破 100% 拿到 SSS+。
    </div>

    <div id="gameContainer" class="game-wrapper">
        <canvas id="gameCanvas" width="900" height="540"></canvas>
        <div class="center-hud">
            <div id="centerScore" class="center-score">0.0000% [D]</div>
            <div id="centerCombo" class="center-combo">Combo 0</div>
            <div id="judgementText" class="center-judge"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        // Pointer 事件：PC 点击 + 大部分移动端触摸 都能走这里
        canvas.addEventListener("pointerdown", (e) => {
            e.preventDefault();

            // iOS 上有时需要 resume 一下 audioCtx
            if (gameState.audioCtx && gameState.audioCtx.state === "suspended") {
                gameState.audioCtx.resume();
            }

            handleTapScreen(e.clientX, e.clientY);
        });

        // 兼容旧设备 / 部分浏览器的 touch 事件
        canvas.addEventListener("touchstart", (e) => {
            // 阻止滚动 / 双指缩放之类
            e.preventDefault();

            if (gameState.audioCtx && gameState.audioCtx.state === "suspended") {
                gameState.audioCtx.resume();
            }

            const touch = e.changedTouches[0];
            if (!touch) return;
            handleTapScreen(touch.clientX, touch.clientY);
        }, { passive: false });

        const fileInput = document.getElementById("fileInput");
        const startBtn = document.getElementById("startBtn");
        const infoText = document.getElementById("infoText");

        const scorePercentEl = document.getElementById("scorePercent");
        const scoreGradeEl = document.getElementById("scoreGrade");
        const comboEl = document.getElementById("combo");
        const maxComboEl = document.getElementById("maxCombo");
        const noteCountEl = document.getElementById("noteCount");

        const countPerfectEl = document.getElementById("countPerfect");
        const countGoodEl = document.getElementById("countGood");
        const countBadEl = document.getElementById("countBad");
        const countMissEl = document.getElementById("countMiss");

        const centreScoreEl = document.getElementById("centerScore");
        const centreComboEl = document.getElementById("centerCombo");
        const judgementTextEl = document.getElementById("judgementText");

        // 轮廓显示控制：从飞入开始一直到命中后 0.25s
        const OUTLINE_SHOW_BEFORE = 0.5;
        const OUTLINE_HIDE_AFTER = 0.25;

        const gameState = {
            audioCtx: null,
            buffer: null,
            source: null,
            isPlaying: false,
            startTime: 0,
            approachTime: 1.2,
            notes: [],
            // 评分相关
            totalNotes: 0,
            scoreValue: 0,        // 所有 note 的加权和 (P=1, G=2/3, B=1/3, M=0)
            combo: 0,
            maxCombo: 0,
            perfectCount: 0,
            goodCount: 0,
            badCount: 0,
            missCount: 0,
            currentScorePercent: 0,
            currentGrade: "D",
            currentGradeLevel: 0, // 用来控制火花大小/命中音大小
            lastJudgement: "",
            lastJudgementTime: 0,
            hitEffects: [],
            bgCircles: []
        };

        // 进入全屏
        function enterFullscreen() {
            const elem = document.documentElement; // 也可以换成 canvas.parentNode

            if (elem.requestFullscreen) {
                return elem.requestFullscreen().catch(() => { });
            } else if (elem.webkitRequestFullscreen) { // Safari
                return elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { // 旧 Edge
                return elem.msRequestFullscreen();
            }
        }

        // 退出全屏
        function exitFullscreen() {
            const doc = document;
            if (
                doc.fullscreenElement ||
                doc.webkitFullscreenElement ||
                doc.msFullscreenElement
            ) {
                if (doc.exitFullscreen) {
                    doc.exitFullscreen();
                } else if (doc.webkitExitFullscreen) {
                    doc.webkitExitFullscreen();
                } else if (doc.msExitFullscreen) {
                    doc.msExitFullscreen();
                }
            }
        }

        function resizeCanvas() {
            const scale = Math.min(window.innerWidth / 1000, window.innerHeight / 650, 1);
            canvas.style.transformOrigin = "top center";
            canvas.style.transform = `scale(${scale})`;
        }
        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();

        function initBackground() {
            gameState.bgCircles = [];
            for (let i = 0; i < 20; i++) {
                gameState.bgCircles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    r: 20 + Math.random() * 60,
                    speed: 0.2 + Math.random() * 0.4,
                    alpha: 0.06 + Math.random() * 0.1
                });
            }
        }
        initBackground();

        // ---------- 音频加载 ----------
        fileInput.addEventListener("change", async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            startBtn.disabled = true;
            judgementTextEl.textContent = "";
            infoText.textContent = "正在解码音频并进行频域分析，请稍等几秒...";

            try {
                const arrayBuffer = await file.arrayBuffer();
                if (!gameState.audioCtx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    gameState.audioCtx = new AC();
                }
                const audioCtx = gameState.audioCtx;
                gameState.buffer = await audioCtx.decodeAudioData(arrayBuffer);

                infoText.textContent = "基于多频段谱通量 + BPM + pattern 生成谱面中...";
                const beats = generateBeatTimes(buffer = gameState.buffer);

                if (beats.length === 0) {
                    infoText.textContent = "节拍检测结果为空，可能是比较平的背景音。你仍可点“开始游戏”体验一下。";
                } else {
                    infoText.textContent = `已生成节奏谱面，约 ${beats.length} 个音符。跟着节奏基本能全连。`;
                }

                prepareNotes(beats);
                gameState.totalNotes = gameState.notes.length;
                noteCountEl.textContent = gameState.totalNotes;
                startBtn.disabled = false;

                resetScoreState();
            } catch (err) {
                console.error(err);
                infoText.textContent = "音频解码失败，请尝试换一首 mp3。";
            }
        });

        // ---------- 频域节拍检测 + pattern ----------
        function generateBeatTimes(buffer) {
            const channelData = buffer.getChannelData(0);
            const sampleRate = buffer.sampleRate;

            const maxSecondsForAnalysis = 99999;
            const maxSamples = Math.min(channelData.length, maxSecondsForAnalysis * sampleRate);

            const frameSize = 2048;
            const hopSize = 1024;

            const bandFreqs = [80, 120, 200, 350, 600, 1000, 2000, 3500];
            const bandWeights = [2.0, 2.0, 1.6, 1.3, 1.0, 0.8, 0.6, 0.4];

            const numFrames = Math.floor((maxSamples - frameSize) / hopSize);
            if (numFrames <= 0) return [];

            const flux = new Array(numFrames).fill(0);
            let prevMagnitudes = new Array(bandFreqs.length).fill(0);

            function goertzel(frame, offset, N, freq, sampleRate) {
                const k = Math.round(0.5 + ((N * freq) / sampleRate));
                const omega = (2 * Math.PI * k) / N;
                const cos = Math.cos(omega);
                const sin = Math.sin(omega);
                const coeff = 2 * cos;
                let q0 = 0, q1 = 0, q2 = 0;
                for (let i = 0; i < N; i++) {
                    q0 = coeff * q1 - q2 + frame[offset + i];
                    q2 = q1;
                    q1 = q0;
                }
                const real = q1 - q2 * cos;
                const imag = q2 * sin;
                return Math.sqrt(real * real + imag * imag);
            }

            // 1. 计算多频段谱通量
            for (let f = 0; f < numFrames; f++) {
                const offset = f * hopSize;
                const mags = [];
                for (let b = 0; b < bandFreqs.length; b++) {
                    const mag = goertzel(channelData, offset, frameSize, bandFreqs[b], sampleRate);
                    mags.push(mag);
                }
                let fluxValue = 0;
                for (let i = 0; i < mags.length; i++) {
                    const diff = mags[i] - prevMagnitudes[i];
                    if (diff > 0) fluxValue += diff * bandWeights[i];
                }
                flux[f] = fluxValue;
                prevMagnitudes = mags;
            }

            // 2. 平滑 + 归一化
            const smoothed = [];
            const smoothSize = 4;
            let maxFlux = 0;
            for (let i = 0; i < flux.length; i++) {
                let sum = 0, count = 0;
                for (let j = -smoothSize; j <= smoothSize; j++) {
                    const idx = i + j;
                    if (idx >= 0 && idx < flux.length) {
                        sum += flux[idx];
                        count++;
                    }
                }
                const v = count ? sum / count : 0;
                smoothed.push(v);
                if (v > maxFlux) maxFlux = v;
            }
            if (maxFlux <= 0) return [];
            for (let i = 0; i < smoothed.length; i++) {
                smoothed[i] /= maxFlux;
            }

            const meanFlux = smoothed.reduce((a, b) => a + b, 0) / smoothed.length;
            const framesPerSecond = sampleRate / hopSize;

            // 3. 估 BPM
            const minTempo = 60;
            const maxTempo = 200;
            const minLag = Math.round(framesPerSecond * 60 / maxTempo);
            const maxLag = Math.round(framesPerSecond * 60 / minTempo);

            let bestLag = null;
            let bestScore = -Infinity;
            for (let lag = minLag; lag <= maxLag; lag++) {
                let score = 0;
                for (let i = 0; i + lag < smoothed.length; i++) {
                    score += smoothed[i] * smoothed[i + lag];
                }
                if (score > bestScore) {
                    bestScore = score;
                    bestLag = lag;
                }
            }
            if (!bestLag) return [];

            let beatPeriod = bestLag / framesPerSecond; // 秒/拍
            beatPeriod = Math.min(Math.max(beatPeriod, 0.25), 1.0);

            // 4. 相位
            const beatWindow = beatPeriod * 0.25;
            const phaseStep = beatPeriod / 32;
            let bestPhase = 0;
            let bestPhaseScore = -Infinity;

            for (let phase = 0; phase < beatPeriod; phase += phaseStep) {
                let score = 0;
                for (let i = 0; i < smoothed.length; i++) {
                    const t = i / framesPerSecond;
                    const n = Math.round((t - phase) / beatPeriod);
                    const beatTime = phase + n * beatPeriod;
                    if (beatTime < 0) continue;
                    const dist = Math.abs(t - beatTime);
                    if (dist <= beatWindow) {
                        const w = 1 - dist / beatWindow;
                        score += smoothed[i] * w;
                    }
                }
                if (score > bestPhaseScore) {
                    bestPhaseScore = score;
                    bestPhase = phase;
                }
            }

            // 5. 小节 + pattern
            const duration = Math.min(buffer.duration, maxSecondsForAnalysis);
            const measureDuration = beatPeriod * 4;
            let firstMeasureStart = bestPhase;
            while (firstMeasureStart < 0) firstMeasureStart += measureDuration;
            if (firstMeasureStart > duration) firstMeasureStart = 0;

            const numMeasures = Math.max(
                1,
                Math.floor((duration - firstMeasureStart) / measureDuration)
            );

            const patterns = {
                low: [
                    [1, 0, 0, 0, 0, 0, 0, 0],
                    [1, 0, 0, 0, 1, 0, 0, 0],
                    [1, 0, 0, 0, 0, 0, 1, 0],
                ],
                mid: [
                    [1, 0, 0, 0, 1, 0, 0, 0],
                    [1, 0, 0, 0, 1, 0, 1, 0],
                    [1, 0, 1, 0, 1, 0, 0, 0],
                    [1, 0, 0, 0, 1, 0, 0, 1],
                ],
                high: [
                    [1, 0, 1, 0, 1, 0, 1, 0],
                    [1, 1, 0, 1, 1, 0, 1, 0],
                    [1, 0, 1, 1, 1, 0, 1, 1],
                    [1, 0, 1, 0, 1, 1, 0, 1],
                ]
            };

            const beats = [];
            const maxNotes = 99999; // 可以改大/改小控制整局音符量

            function snapToLocalPeak(timeSeconds) {
                const searchRadius = beatPeriod * 0.2;
                const startT = Math.max(0, timeSeconds - searchRadius);
                const endT = Math.min(duration, timeSeconds + searchRadius);

                const startIndex = Math.max(0, Math.floor(startT * framesPerSecond));
                const endIndex = Math.min(smoothed.length - 1, Math.ceil(endT * framesPerSecond));

                let bestIdx = null;
                let bestVal = -Infinity;
                for (let i = startIndex; i <= endIndex; i++) {
                    const v = smoothed[i];
                    if (v > bestVal) {
                        bestVal = v;
                        bestIdx = i;
                    }
                }
                if (bestIdx == null) return timeSeconds;
                return bestIdx / framesPerSecond;
            }

            for (let m = 0; m < numMeasures; m++) {
                const measureStart = firstMeasureStart + m * measureDuration;
                const measureEnd = measureStart + measureDuration;
                if (measureStart >= duration) break;

                let sum = 0, count = 0;
                const startIndex = Math.max(0, Math.floor(measureStart * framesPerSecond));
                const endIndex = Math.min(smoothed.length - 1, Math.ceil(measureEnd * framesPerSecond));
                for (let i = startIndex; i <= endIndex; i++) {
                    sum += smoothed[i];
                    count++;
                }
                const intensity = count ? sum / count : 0;

                let bucket = "mid";
                if (intensity < 0.25) bucket = "low";
                else if (intensity > 0.6) bucket = "high";

                const bucketPatterns = patterns[bucket];
                const pattern = bucketPatterns[Math.floor(Math.random() * bucketPatterns.length)];

                for (let s = 0; s < pattern.length; s++) {
                    if (!pattern[s]) continue;

                    const slotOffset = (beatPeriod / 2) * s; // 8分音
                    let t = measureStart + slotOffset;
                    if (t < 0 || t > duration) continue;

                    const tFrame = Math.round(t * framesPerSecond);
                    const radiusFrames = Math.round(beatWindow * framesPerSecond);
                    let localSum = 0, localCount = 0;
                    for (let k = -radiusFrames; k <= radiusFrames; k++) {
                        const idx = tFrame + k;
                        if (idx >= 0 && idx < smoothed.length) {
                            localSum += smoothed[idx];
                            localCount++;
                        }
                    }
                    const localAvg = localCount ? localSum / localCount : 0;

                    // 弱句的格子，有一定概率不出 note
                    if (localAvg < meanFlux * 0.9 && Math.random() < 0.4) {
                        continue;
                    }

                    const snappedTime = snapToLocalPeak(t);
                    beats.push(snappedTime);
                    if (beats.length >= maxNotes) break;
                }
                if (beats.length >= maxNotes) break;
            }

            if (beats.length === 0) {
                const fallbackBeats = [];
                const durationSafe = Math.min(buffer.duration, maxSecondsForAnalysis);
                for (let t = 0; t < durationSafe; t += beatPeriod) {
                    fallbackBeats.push(t);
                    if (fallbackBeats.length >= maxNotes) break;
                }
                return fallbackBeats;
            }

            beats.sort((a, b) => a - b);
            const merged = [];
            const minGap = 0.04;
            for (let i = 0; i < beats.length; i++) {
                if (i === 0 || beats[i] - merged[merged.length - 1] > minGap) {
                    merged.push(beats[i]);
                }
            }
            return merged;
        }

        function prepareNotes(beats) {
            gameState.notes = [];
            const margin = 90;
            const baseRadius = 40;
            const approach = gameState.approachTime;

            for (const t of beats) {
                const spawnTime = t - approach;
                const x = margin + Math.random() * (canvas.width - margin * 2);
                const y = margin + Math.random() * (canvas.height - margin * 2);
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.max(canvas.width, canvas.height) * 0.7;
                const spawnX = x + Math.cos(angle) * distance;
                const spawnY = y + Math.sin(angle) * distance;
                const radius = baseRadius * (0.9 + Math.random() * 0.3);

                gameState.notes.push({
                    targetTime: t,
                    spawnTime: spawnTime < 0 ? 0 : spawnTime,
                    x, y, radius,
                    spawnX, spawnY,
                    hit: false,
                    missed: false,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() * 2 - 1) * 1.5,
                    trail: [],
                    prevOutline: null   // 先占位
                });
            }

            // 按时间顺序为每个 note 记录“上一个轮廓”
            // 默认 beats 已经按时间排序了；防御起见再 sort 一次
            gameState.notes.sort((a, b) => a.targetTime - b.targetTime);
            for (let i = 0; i < gameState.notes.length; i++) {
                if (i === 0) {
                    gameState.notes[i].prevOutline = null;
                } else {
                    gameState.notes[i].prevOutline = gameState.notes[i - 1];
                }
            }
        }


        // ---------- 游戏控制 ----------
        startBtn.addEventListener("click", async () => {
            if (!gameState.buffer || !gameState.audioCtx) return;

            // 显示纯游戏画面
            enterGameplayScreen();
            await enterFullscreen();

            startGame();
        });
        function enterGameplayScreen() {
            document.body.style.overflow = "hidden";

            // 隐藏上方 UI
            document.querySelector("h1").style.display = "none";
            document.querySelector(".panel").style.display = "none";
            document.querySelector(".info").style.display = "none";
            document.querySelector(".stats").style.display = "none";
            document.querySelector(".judge-stats").style.display = "none";
            document.querySelector(".hint").style.display = "none";

            // Canvas 全屏化
            document.getElementById("gameContainer").classList.add("fullscreen-play");
        }



        function startGame() {
            const audioCtx = gameState.audioCtx;
            if (gameState.source) {
                try { gameState.source.stop(); } catch { }
            }
            const source = audioCtx.createBufferSource();
            source.buffer = gameState.buffer;
            source.connect(audioCtx.destination);
            source.start();

            gameState.source = source;
            gameState.startTime = audioCtx.currentTime;
            gameState.isPlaying = true;

            resetScoreState();

            for (const n of gameState.notes) {
                n.hit = false;
                n.missed = false;
                n.trail = [];
            }
        }

        function resetScoreState() {
            gameState.scoreValue = 0;
            gameState.combo = 0;
            gameState.maxCombo = 0;
            gameState.perfectCount = 0;
            gameState.goodCount = 0;
            gameState.badCount = 0;
            gameState.missCount = 0;
            gameState.currentScorePercent = 0;
            gameState.currentGrade = "D";
            gameState.currentGradeLevel = 0;
            gameState.lastJudgement = "";
            judgementTextEl.textContent = "";

            updateScoreAndUI();
        }

        // ---------- 判定 ----------
        window.addEventListener("keydown", (e) => {
            if (e.code === "Space") {
                e.preventDefault();
                handleHit();
            }
        });
        // 点击 / 触摸击打音符（移动端 / PC 点按）
        function handleTapScreen(clientX, clientY) {
            if (!gameState.isPlaying || !gameState.audioCtx) return;

            const now = gameState.audioCtx.currentTime - gameState.startTime;

            // 把屏幕坐标换成 canvas 内坐标（考虑 CSS 缩放）
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;

            let bestNote = null;
            let bestTimeDiff = Infinity;
            let bestDistRatio = Infinity;

            for (const note of gameState.notes) {
                if (note.hit || note.missed) continue;

                const dt = Math.abs(note.targetTime - now);
                // 时间离得太远就不考虑了
                if (dt > 0.32) continue;

                const pos = getNotePosition(note, now);
                const dist = Math.hypot(pos.x - x, pos.y - y);
                const distRatio = dist / note.radius;

                // 点击距离太远的也不要
                if (distRatio > 11.8) continue;

                // 综合时间 + 距离，选一个“最合理的 note”
                const score = dt * 1.0 + distRatio * 0.06;
                if (score < bestTimeDiff) {
                    bestTimeDiff = dt;
                    bestTimeDiff = dt;
                    bestDistRatio = distRatio;
                    bestNote = note;
                }
            }

            // 没找到合适 note，就算一次 MISS 空挥
            if (!bestNote) {
                applyJudgement(null, "MISS");
                return;
            }

            // 下面这块判定逻辑请用你当前 handleHit 里那段：
            // （如果你已经按“更松判定”改过，就把那一段原样搬过来）
            let result = "MISS";

            // 示例：比较宽松版
            const tPerfect = 0.11;
            const tGood = 0.18;
            const tBad = 0.26;
            const dPerfect = 0.60;
            const dGood = 1.00;
            const dBad = 1.50;

            if (bestTimeDiff <= tPerfect && bestDistRatio <= dPerfect) {
                result = "PERFECT";
            } else if (bestTimeDiff <= tGood && bestDistRatio <= dGood) {
                result = "GOOD";
            } else if (bestTimeDiff <= tBad && bestDistRatio <= dBad) {
                result = "BAD";
            } else {
                result = "MISS";
            }

            if (result === "MISS") {
                bestNote.missed = true;
            } else {
                bestNote.hit = true;
            }

            applyJudgement(bestNote, result);
        }

        function handleHit() {
            if (!gameState.isPlaying || !gameState.audioCtx) return;
            const now = gameState.audioCtx.currentTime - gameState.startTime;

            let bestNote = null;
            let bestTimeDiff = Infinity;

            for (const note of gameState.notes) {
                if (note.hit || note.missed) continue;
                const dt = Math.abs(note.targetTime - now);
                if (dt > 0.28) continue;
                if (dt < bestTimeDiff) {
                    bestTimeDiff = dt;
                    bestNote = note;
                }
            }

            if (!bestNote) {
                applyJudgement(null, "MISS"); // 空挥，算 MISS 不挂在音符上
                return;
            }

            const currentPos = getNotePosition(bestNote, now);
            const dist = Math.hypot(currentPos.x - bestNote.x, currentPos.y - bestNote.y);
            const distRatio = dist / bestNote.radius;

            // ----- 更松的判定线（推荐版） -----

            // 时间轴（秒）
            // 原版 Perfect ≈70ms，现在放宽到 ≈110ms
            // GOOD 放宽到 ≈180ms
            // BAD 放宽到 ≈260ms
            const tPerfect = 0.11;
            const tGood = 0.18;
            const tBad = 0.26;

            // 距离比例（图形中心距离 / 半径）
            // 放宽范围，使图形未完全重合也能判定
            const dPerfect = 991.10;   // 原来是 0.45
            const dGood = 991.80;   // 原来是 0.75
            const dBad = 992.60;   // 原来是 1.1

            let result = "MISS";

            if (bestTimeDiff <= tPerfect && distRatio <= dPerfect) {
                result = "PERFECT";
            } else if (bestTimeDiff <= tGood && distRatio <= dGood) {
                result = "GOOD";
            } else if (bestTimeDiff <= tBad && distRatio <= dBad) {
                result = "BAD";
            } else {
                result = "MISS";
            }


            // 命中后图形/轮廓/引导线全部消失
            if (result === "MISS") {
                bestNote.missed = true;
            } else {
                bestNote.hit = true;
            }

            applyJudgement(bestNote, result);
        }

        function applyJudgement(note, result) {
            // 评分权重
            let weight = 0;
            if (result === "PERFECT") weight = 1.0;
            else if (result === "GOOD") weight = 2 / 3;
            else if (result === "BAD") weight = 1 / 3;
            else weight = 0;

            // 命中音符（非空挥）才计入 scoreValue；空 MISS 只影响 combo 和 MISS 统计
            if (note) {
                gameState.scoreValue += weight;
            }

            if (result === "PERFECT") gameState.perfectCount++;
            else if (result === "GOOD") gameState.goodCount++;
            else if (result === "BAD") gameState.badCount++;
            else gameState.missCount++;

            // Combo：PERFECT / GOOD 维持连击；BAD/MISS 断
            if (result !== "MISS") {
                gameState.combo += 1;
                if (gameState.combo > gameState.maxCombo) {
                    gameState.maxCombo = gameState.combo;
                }
            } else {
                gameState.combo = 0;
            }

            registerJudgement(result);
            if (note) {
                spawnHitEffect(note.x, note.y, result);
            }
            playHitSound(result);

            updateScoreAndUI();
        }

        function registerJudgement(text) {
            gameState.lastJudgement = text;
            gameState.lastJudgementTime = performance.now() / 1000;
        }

        // 分数 & 评级计算
        function getGradeFromPercent(p) {
            // p 是可能 > 100 的最终分（包含连击加成）
            if (p > 100) return { label: "SSS+", level: 9 };
            if (p >= 99.75) return { label: "SSS", level: 8 };
            if (p >= 99.5) return { label: "SS+", level: 7 };
            if (p >= 99) return { label: "SS", level: 6 };
            if (p >= 98) return { label: "S+", level: 5 };
            if (p >= 97) return { label: "S", level: 4 };
            if (p >= 90) return { label: "A", level: 3 };
            if (p >= 80) return { label: "B", level: 2 };
            if (p >= 60) return { label: "C", level: 1 };
            return { label: "D", level: 0 };
        }

        function updateScoreAndUI() {
            const total = gameState.totalNotes || 1;
            const rawAccuracy = gameState.scoreValue / total; // 0~1
            let basePercent = rawAccuracy * 100;

            if (basePercent < 0) basePercent = 0;

            // 连击加成：最大 +2%，maxCombo = totalNotes 时拿满
            const comboBonus = (gameState.maxCombo / total) * 2; // 0~2
            let finalPercent = basePercent + comboBonus;

            gameState.currentScorePercent = finalPercent;
            const gradeInfo = getGradeFromPercent(finalPercent);
            gameState.currentGrade = gradeInfo.label;
            gameState.currentGradeLevel = gradeInfo.level;

            scorePercentEl.textContent = finalPercent.toFixed(4) + "%";
            scoreGradeEl.textContent = gradeInfo.label;
            comboEl.textContent = gameState.combo;
            maxComboEl.textContent = gameState.maxCombo;

            countPerfectEl.textContent = gameState.perfectCount;
            countGoodEl.textContent = gameState.goodCount;
            countBadEl.textContent = gameState.badCount;
            countMissEl.textContent = gameState.missCount;

            centreScoreEl.textContent = finalPercent.toFixed(4) + "% [" + gradeInfo.label + "]";
            centreComboEl.textContent = "Combo " + gameState.combo;
        }

        // 找到当前时刻下一个要击打的音符（用于高亮）
        function findNextTargetNote(nowAudio) {
            let bestNote = null;
            let bestScore = Infinity;

            for (const note of gameState.notes) {
                if (note.hit || note.missed) continue;

                // 距离判定时刻的时间差
                const dt = note.targetTime - nowAudio;

                // 已经过了很久的+还没到很远的都不考虑
                if (dt < -0.25 || dt > 3) continue;

                // 得分函数：越接近 targetTime 优先级越高，已经过时一点的也优先
                const score = Math.abs(dt);

                if (score < bestScore) {
                    bestScore = score;
                    bestNote = note;
                }
            }

            return bestNote;
        }

        function getNotePosition(note, audioTime) {
            const t = (audioTime - note.spawnTime) / gameState.approachTime;
            const progress = Math.min(Math.max(t, 0), 1.3);
            return {
                x: note.spawnX + (note.x - note.spawnX) * progress,
                y: note.spawnY + (note.y - note.spawnY) * progress,
                progress
            };
        }

        // ---------- 命中音 ----------
        function playHitSound(result) {
            if (!gameState.audioCtx) return;
            const ctxAudio = gameState.audioCtx;

            const osc = ctxAudio.createOscillator();
            const gain = ctxAudio.createGain();

            let freq = 880;
            let baseGain = 0.18;
            let duration = 0.06;

            if (result === "PERFECT") {
                freq = 1100;
                baseGain = 0.15;
                duration = 0.045;
            } else if (result === "GOOD") {
                freq = 900;
                baseGain = 0.2;
                duration = 0.06;
            } else if (result === "BAD") {
                freq = 600;
                baseGain = 0.25;
                duration = 0.08;
            } else { // MISS
                freq = 400;
                baseGain = 0.2;
                duration = 0.05;
            }

            // 评级越高，音量越小
            const gradeLevel = gameState.currentGradeLevel || 0;
            const volumeFactor = Math.max(0.3, 1 - gradeLevel * 0.07); // 从 1 ~ 0.3
            baseGain *= volumeFactor;

            osc.frequency.value = freq;
            osc.type = "sine";

            const now = ctxAudio.currentTime;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(baseGain, now + 0.003);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

            osc.connect(gain);
            gain.connect(ctxAudio.destination);

            osc.start(now);
            osc.stop(now + duration + 0.02);
        }

        // ---------- 特效 ----------
        function spawnHitEffect(x, y, type) {
            const now = performance.now() / 1000;

            let color;
            if (type === "PERFECT") color = "rgba(255,255,255,1)";
            else if (type === "GOOD") color = "rgba(180,255,220,1)";
            else if (type === "BAD") color = "rgba(255,220,180,1)";
            else color = "rgba(255,160,160,1)";

            // 评级越高，火花越大
            const gradeScale = 1 + (gameState.currentGradeLevel || 0) * 0.08;
            let baseScale = 1;
            let duration = 0.35;
            if (type === "PERFECT") {
                baseScale = 1.3;
                duration = 0.4;
            } else if (type === "GOOD") {
                baseScale = 1.0;
                duration = 0.35;
            } else if (type === "BAD") {
                baseScale = 0.8;
                duration = 0.3;
            } else {
                baseScale = 0.6;
                duration = 0.25;
            }

            const scale = baseScale * gradeScale;

            gameState.hitEffects.push({
                x,
                y,
                startTime: now,
                duration,
                color,
                scale
            });
        }

        // ---------- 渲染 ----------
        function drawBackground(deltaTime) {
            ctx.save();
            ctx.fillStyle = "rgba(2,6,23,0.8)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (const c of gameState.bgCircles) {
                c.y -= c.speed * deltaTime * 60;
                if (c.y + c.r < 0) {
                    c.y = canvas.height + c.r;
                    c.x = Math.random() * canvas.width;
                }
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(148,163,184,${c.alpha})`;
                ctx.fill();
            }
            ctx.restore();
        }

        // 轮廓 + 判定环（与图形同步出现；判定环节奏仍参考 targetTime）
        function drawOutlineAndJudgeRing(note, audioTime, targetNote) {
            if (note.hit || note.missed) return;

            const appearTime = note.spawnTime;
            const disappearTime = note.targetTime + OUTLINE_HIDE_AFTER;

            if (audioTime < appearTime || audioTime > disappearTime) {
                return;
            }

            const isTarget = (note === targetNote);

            ctx.save();

            // 1. 轮廓（目标图形）
            ctx.lineWidth = isTarget ? 5 : 3;
            const baseAlpha = isTarget ? 0.9 : 0.5;
            ctx.strokeStyle = isTarget
                ? "rgba(244,244,255,0.95)"
                : `rgba(148,163,255,${baseAlpha})`;

            const sides = 4 + ((note.x + note.y) | 0) % 3;
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                const r = note.radius * (isTarget ? 1.25 : 1.1);
                const px = note.x + Math.cos(angle) * r;
                const py = note.y + Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.stroke();

            // 2. 判定环：目标 note 有更亮的外圈
            const dt = note.targetTime - audioTime;
            const remaining = Math.min(Math.max(dt, 0), OUTLINE_SHOW_BEFORE);
            const k = OUTLINE_SHOW_BEFORE > 0 ? remaining / OUTLINE_SHOW_BEFORE : 0;
            const scale = 1 + 1.4 * k;
            const ringRadius = note.radius * scale * 1.1;
            const ringAlpha = (isTarget ? 0.4 : 0.2) + (1 - k) * (isTarget ? 0.6 : 0.5);

            ctx.beginPath();
            ctx.arc(note.x, note.y, ringRadius, 0, Math.PI * 2);
            ctx.strokeStyle = isTarget
                ? `rgba(244,244,255,${ringAlpha})`
                : `rgba(248,250,252,${ringAlpha})`;
            ctx.lineWidth = isTarget ? 3 : 2;
            ctx.setLineDash(isTarget ? [2, 8] : [6, 10]);
            ctx.stroke();

            ctx.restore();
        }


        function drawNote(note, audioTime, deltaTime, targetNote) {
            if (note.hit || note.missed) return;

            const pos = getNotePosition(note, audioTime);
            if (pos.progress <= 0) return;
            if (pos.progress > 1.3) {
                if (!note.hit && !note.missed) {
                    note.missed = true;
                    applyJudgement(note, "MISS");
                }
                return;
            }

            const isTarget = (note === targetNote);

            // 引导线：目标 note 的引导线更粗更亮
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            ctx.lineTo(note.x, note.y);
            const gradientLine = ctx.createLinearGradient(pos.x, pos.y, note.x, note.y);
            if (isTarget) {
                gradientLine.addColorStop(0, "rgba(248,250,252,0.95)");
                gradientLine.addColorStop(1, "rgba(129,140,248,0.0)");
            } else {
                gradientLine.addColorStop(0, "rgba(96,165,250,0.8)");
                gradientLine.addColorStop(1, "rgba(148,163,255,0.0)");
            }
            ctx.strokeStyle = gradientLine;
            ctx.lineWidth = isTarget ? 3 : 2;
            ctx.setLineDash(isTarget ? [2, 10] : [4, 12]);
            ctx.stroke();
            ctx.restore();

            // 拖尾
            note.trail.push({ x: pos.x, y: pos.y });
            if (note.trail.length > 18) note.trail.shift();

            ctx.save();
            ctx.lineJoin = "round";
            ctx.lineCap = "round";

            for (let i = 0; i < note.trail.length; i++) {
                const p = note.trail[i];
                const alpha = (i + 1) / note.trail.length;
                ctx.beginPath();
                ctx.arc(p.x, p.y, note.radius * 0.5 * (i / note.trail.length), 0, Math.PI * 2);
                ctx.fillStyle = isTarget
                    ? `rgba(248,250,252,${alpha * 0.45})`
                    : `rgba(96,165,250,${alpha * 0.35})`;
                ctx.fill();
            }

            const p = Math.min(Math.max(pos.progress, 0), 1);
            let sizeScale = 0.85 + 0.35 * Math.sin(p * Math.PI * 0.5);
            if (isTarget) {
                // 当前目标做一点呼吸放大
                sizeScale *= 1.08;
            }
            const drawRadius = note.radius * sizeScale;

            note.rotation += note.rotationSpeed * deltaTime;

            ctx.translate(pos.x, pos.y);
            ctx.rotate(note.rotation);

            const gradient = ctx.createRadialGradient(
                0, 0, drawRadius * 0.2,
                0, 0, drawRadius
            );
            if (isTarget) {
                gradient.addColorStop(0, "rgba(248,250,252,1.0)");
                gradient.addColorStop(0.35, "rgba(191,219,254,0.95)");
                gradient.addColorStop(1, "rgba(129,140,248,0.9)");
            } else {
                gradient.addColorStop(0, "rgba(248,250,252,0.95)");
                gradient.addColorStop(0.4, "rgba(129, 140, 248,0.9)");
                gradient.addColorStop(1, "rgba(236, 72, 153,0.7)");
            }

            ctx.beginPath();
            const sides = 4 + ((note.x + note.y) | 0) % 3;
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                const r = drawRadius * (0.8 + (i % 2) * 0.2);
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.lineWidth = isTarget ? 3 : 2;
            ctx.strokeStyle = isTarget
                ? "rgba(15,23,42,1)"
                : "rgba(15,23,42,0.9)";
            ctx.stroke();

            ctx.restore();
        }

        function drawHitEffects(now) {
            ctx.save();
            for (let i = gameState.hitEffects.length - 1; i >= 0; i--) {
                const e = gameState.hitEffects[i];
                const t = (now - e.startTime) / e.duration;
                if (t >= 1) {
                    gameState.hitEffects.splice(i, 1);
                    continue;
                }
                const radius = (10 + t * 60) * e.scale;
                ctx.beginPath();
                ctx.arc(e.x, e.y, radius, 0, Math.PI * 2);
                ctx.strokeStyle = e.color.replace("1)", `${1 - t})`);
                ctx.lineWidth = 3 * (1 - t);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawJudgement(now) {
            if (!gameState.lastJudgement) {
                judgementTextEl.textContent = "";
                return;
            }
            const elapsed = now - gameState.lastJudgementTime;
            const duration = 0.9;
            if (elapsed > duration) {
                gameState.lastJudgement = "";
                judgementTextEl.textContent = "";
                return;
            }

            const t = elapsed / duration;
            const scale = 1 + 0.5 * (1 - t);
            const opacity = 1 - t;

            judgementTextEl.textContent = gameState.lastJudgement;
            judgementTextEl.style.transform = `scale(${scale})`;
            const color =
                gameState.lastJudgement === "PERFECT"
                    ? `rgba(248,250,252,${opacity})`
                    : gameState.lastJudgement === "GOOD"
                        ? `rgba(190,242,100,${opacity})`
                        : gameState.lastJudgement === "BAD"
                            ? `rgba(251,191,36,${opacity})`
                            : `rgba(248,113,113,${opacity})`;
            judgementTextEl.style.color = color;
        }

        function exitGameplayScreen() {
            document.body.style.overflow = "auto";

            // 恢复 UI
            document.querySelector("h1").style.display = "";
            document.querySelector(".panel").style.display = "";
            document.querySelector(".info").style.display = "";
            document.querySelector(".stats").style.display = "";
            document.querySelector(".judge-stats").style.display = "";
            document.querySelector(".hint").style.display = "";

            // 取消全屏 Canvas 布局
            document.getElementById("gameContainer").classList.remove("fullscreen-play");
        }

        let lastFrameTime = performance.now();
        function loop() {
            requestAnimationFrame(loop);
            const nowPerf = performance.now();
            const deltaMs = nowPerf - lastFrameTime;
            lastFrameTime = nowPerf;
            const deltaTime = deltaMs / 1000;

            const nowAudio =
                gameState.isPlaying && gameState.audioCtx
                    ? gameState.audioCtx.currentTime - gameState.startTime
                    : 0;

            // 每帧找出下一个目标音符
            const targetNote = findNextTargetNote(nowAudio);

            drawBackground(deltaTime);

            for (const note of gameState.notes) {
                drawOutlineAndJudgeRing(note, nowAudio, targetNote);
            }

            for (const note of gameState.notes) {
                drawNote(note, nowAudio, deltaTime, targetNote);
            }


            drawHitEffects(nowPerf / 1000);
            drawJudgement(nowPerf / 1000);

            if (
                gameState.isPlaying &&
                gameState.buffer &&
                nowAudio > gameState.buffer.duration + 0.3
            ) {
                gameState.isPlaying = false;
                exitGameplayScreen();
                exitFullscreen();
                infoText.textContent = "本曲结束。可重新点击“开始游戏”再玩一次。";
            }

        }
        loop();
    </script>
</body>

</html>
